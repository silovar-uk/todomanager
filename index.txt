import React, { useState, useRef, useEffect, useCallback } from 'react';
import { Plus, Check, X, Trash2, BarChart3, Target, ChevronDown, ChevronRight, Download, Upload, Lightbulb, FileText, HelpCircle, ArrowUp, AlertTriangle } from 'lucide-react';

export default function TodoApp() {
  // ã‚¿ã‚¹ã‚¯ã®è‰²å®šç¾© (ç·‘ã¯AIåˆ†è§£ã‚¿ã‚¹ã‚¯ã€è–„ç´«ã¯AIã‚¢ã‚¤ãƒ‡ã‚¢å‡ºã—ã‚¿ã‚¹ã‚¯ã€é»’ã¯AIå•ã„ç”Ÿæˆã‚¿ã‚¹ã‚¯)
  const colors = ['#3B82F6', '#EF4444', '#FBBF24', '#22C55E', '#A78BFA', '#1F2937'];

  const [tasks, setTasks] = useState([]); // å…¨ã‚¿ã‚¹ã‚¯ã®ã‚¹ãƒ†ãƒ¼ãƒˆ
  const [expandedTasks, setExpandedTasks] = useState(new Set()); // å±•é–‹ã•ã‚Œã¦ã„ã‚‹ã‚¿ã‚¹ã‚¯ã®IDã‚’ä¿æŒã™ã‚‹Set
  const [showAddForm, setShowAddForm] = useState(null); // ã‚¿ã‚¹ã‚¯è¿½åŠ ãƒ•ã‚©ãƒ¼ãƒ ã®è¡¨ç¤ºçŠ¶æ…‹ (null, 'root', ã¾ãŸã¯è¦ªã‚¿ã‚¹ã‚¯ID)
  const [showImportArea, setShowImportArea] = useState(false); // ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒªã‚¢ã®è¡¨ç¤ºçŠ¶æ…‹
  const [notification, setNotification] = useState(''); // é€šçŸ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚¹ãƒ†ãƒ¼ãƒˆ
  const [editingTask, setEditingTask] = useState(null); // ç·¨é›†ä¸­ã®ã‚¿ã‚¹ã‚¯ID
  const [showColorPicker, setShowColorPicker] = useState(null); // ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ã®è¡¨ç¤ºçŠ¶æ…‹ (null ã¾ãŸã¯ã‚¿ã‚¹ã‚¯ID)
  const [selectedTaskId, setSelectedTaskId] = useState(null); // é¸æŠžä¸­ã®ã‚¿ã‚¹ã‚¯ID
  const [isEmptyAreaSelected, setIsEmptyAreaSelected] = useState(false); // ç©ºã®ã‚¨ãƒªã‚¢ãŒé¸æŠžã•ã‚Œã¦ã„ã‚‹ã‹
  const [newTaskColor, setNewTaskColor] = useState(colors[0]); // æ–°è¦ã‚¿ã‚¹ã‚¯ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè‰²
  const [showNewTaskColorPicker, setShowNewTaskColorPicker] = useState(false); // æ–°è¦ã‚¿ã‚¹ã‚¯ç”¨ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ã®è¡¨ç¤ºçŠ¶æ…‹
  const [exportedData, setExportedData] = useState(''); // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿
  const [showExportedData, setShowExportedData] = useState(false); // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã®è¡¨ç¤ºçŠ¶æ…‹
  const [selectedColorIndex, setSelectedColorIndex] = useState(0); // ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ã§é¸æŠžä¸­ã®è‰²ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
  const [showExportOptions, setShowExportOptions] = useState(false); // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®è¡¨ç¤ºçŠ¶æ…‹
  const [exportDropdownPosition, setExportDropdownPosition] = useState({ top: 0, left: 0 }); // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã®ä½ç½®
  const [importMode, setImportMode] = useState('add'); // ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ‰: 'add' (è¿½åŠ ) ã¾ãŸã¯ 'overwrite' (ä¸Šæ›¸ã)
  const [isGeneratingSubtasks, setIsGeneratingSubtasks] = useState(false); // ã‚µãƒ–ã‚¿ã‚¹ã‚¯ç”Ÿæˆä¸­ãƒ•ãƒ©ã‚°
  const [isGeneratingIdeas, setIsGeneratingIdeas] = useState(false); // ã‚¢ã‚¤ãƒ‡ã‚¢ç”Ÿæˆä¸­ãƒ•ãƒ©ã‚°
  const [isGeneratingQuestions, setIsGeneratingQuestions] = useState(false); // å•ã„ç”Ÿæˆä¸­ãƒ•ãƒ©ã‚°
  const [showMemoModal, setShowMemoModal] = useState(null); // ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ€ãƒ«ã®è¡¨ç¤ºçŠ¶æ…‹ (null ã¾ãŸã¯ã‚¿ã‚¹ã‚¯ID)
  const [currentMemo, setCurrentMemo] = useState(''); // ç¾åœ¨ç·¨é›†ä¸­ã®ãƒ¡ãƒ¢å†…å®¹
  const [isFocusMode, setIsFocusMode] = useState(false); // é›†ä¸­ãƒ¢ãƒ¼ãƒ‰ã®ã‚ªãƒ³/ã‚ªãƒ•
  const [exportInProgress, setExportInProgress] = useState(false); // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå‡¦ç†ä¸­ãƒ•ãƒ©ã‚°
  const [showDeleteCompletedConfirmModal, setShowDeleteCompletedConfirmModal] = useState(false); // å®Œäº†ã‚¿ã‚¹ã‚¯å‰Šé™¤ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«ã®è¡¨ç¤ºçŠ¶æ…‹

  // UNDOæ©Ÿèƒ½ã®ãŸã‚ã®ã‚¹ãƒ†ãƒ¼ãƒˆã¨å‚ç…§
  const [lastDeletedTaskInfo, setLastDeletedTaskInfo] = useState(null); // { task: {}, parentId: null, originalIndex: -1 }
  const undoNotificationTimerRef = useRef(null);

  const mainInputRef = useRef(null); // ãƒ¡ã‚¤ãƒ³ã®ã‚¿ã‚¹ã‚¯å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‚ç…§
  const subtaskInputRefs = useRef({}); // ã‚µãƒ–ã‚¿ã‚¹ã‚¯å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‚ç…§ã‚’ç®¡ç†ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
  const editInputRefs = useRef({}); // ç·¨é›†å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‚ç…§ã‚’ç®¡ç†ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
  const exportButtonRef = useRef(null); // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®å‚ç…§
  const editingTaskRef = useRef(null);

  // editingTaskã®æœ€æ–°å€¤ã‚’ä¿æŒã™ã‚‹ãŸã‚ã®ref
  useEffect(() => {
    editingTaskRef.current = editingTask;
  }, [editingTask]);

  // Load tasks from localStorage on initial mount
  useEffect(() => {
    try {
        const savedTasks = localStorage.getItem('todoAppTasks_v2');
        if (savedTasks) {
            const parsedTasks = JSON.parse(savedTasks);
            const reviveDates = (taskList) => taskList.map(task => ({
                ...task,
                createdAt: task.createdAt ? new Date(task.createdAt) : null,
                completedAt: task.completedAt ? new Date(task.completedAt) : null,
                subtasks: task.subtasks ? reviveDates(task.subtasks) : []
            }));
            setTasks(reviveDates(parsedTasks));
        }
        const savedExpandedTasks = localStorage.getItem('todoAppExpandedTasks_v2');
        if (savedExpandedTasks) {
            setExpandedTasks(new Set(JSON.parse(savedExpandedTasks)));
        }
    } catch (error) {
        console.error("Failed to load tasks from localStorage", error);
        localStorage.removeItem('todoAppTasks_v2');
        localStorage.removeItem('todoAppExpandedTasks_v2');
    }
  }, []);

  // Save tasks to localStorage whenever they change
  useEffect(() => {
    try {
        localStorage.setItem('todoAppTasks_v2', JSON.stringify(tasks));
    } catch (error) {
        console.error("Failed to save tasks to localStorage", error);
    }
  }, [tasks]);

  // Save expanded tasks to localStorage whenever they change
  useEffect(() => {
    try {
        localStorage.setItem('todoAppExpandedTasks_v2', JSON.stringify(Array.from(expandedTasks)));
    } catch (error) {
        console.error("Failed to save expanded tasks to localStorage", error);
    }
  }, [expandedTasks]);

  // beforeunload event listener for data loss warning
  useEffect(() => {
    const handleBeforeUnload = (e) => {
        if (exportInProgress) {
            return;
        }
        const hasData = tasks.length > 0;
        const isEditingCurrentTask = editingTask !== null;
        const isAddingRootTask = showAddForm === 'root' && mainInputRef.current?.value?.trim() !== '';
        let isAddingSubTask = false;
        if (typeof showAddForm === 'string' && showAddForm !== 'root') {
            const subtaskInput = subtaskInputRefs.current[showAddForm];
            if (subtaskInput && subtaskInput.value?.trim() !== '') {
                isAddingSubTask = true;
            }
        }
        const hasUnsavedChanges = hasData || isEditingCurrentTask || isAddingRootTask || isAddingSubTask;
        if (hasUnsavedChanges) {
            const message = 'å†…å®¹ã¯ä¿å­˜ã•ã‚Œã¾ã›ã‚“ã€‚ãƒšãƒ¼ã‚¸ã‚’é›¢ã‚Œã‚‹ã¨ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ãŒå¤±ã‚ã‚Œã¾ã™ã€‚ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã¯å®Œäº†ã—ã¾ã—ãŸã‹ï¼Ÿ';
            e.preventDefault();
            e.returnValue = message;
            return message;
        }
    };
    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => {
        window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [tasks, editingTask, showAddForm, exportInProgress]);


  // é€šçŸ¥ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
  const showNotification = useCallback((message) => {
    setNotification(message);
    if (undoNotificationTimerRef.current) {
      clearTimeout(undoNotificationTimerRef.current);
    }
    undoNotificationTimerRef.current = setTimeout(() => {
      setNotification('');
      setLastDeletedTaskInfo(null);
      if (editingTaskRef.current) {
        const inputElement = editInputRefs.current[editingTaskRef.current];
        if (inputElement) {
          inputElement.focus();
          inputElement.select();
        }
      }
    }, 3000);
  }, []);

  // ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªIDã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
  const generateId = () => Math.random().toString(36).substr(2, 9);

  // HEXã‚«ãƒ©ãƒ¼ã‚’RGBã«å¤‰æ›ã™ã‚‹é–¢æ•°
  const hexToRgb = (hex) => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  };

  // ã‚¿ã‚¹ã‚¯ã®èƒŒæ™¯è‰²ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•° (éšŽå±¤ã«å¿œã˜ã¦é€æ˜Žåº¦ã‚’èª¿æ•´)
  const getTaskBackgroundColor = (color, level) => {
    const rgb = hexToRgb(color);
    if (!rgb) return 'rgba(255, 255, 255, 1)';
    const baseOpacity = 0.1;
    const levelOpacity = Math.min(baseOpacity + (level * 0.08), 0.6);
    return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${levelOpacity})`;
  };

  // ã‚¿ã‚¹ã‚¯ã®ãƒœãƒ¼ãƒ€ãƒ¼è‰²ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•° (éšŽå±¤ã«å¿œã˜ã¦é€æ˜Žåº¦ã‚’èª¿æ•´)
  const getTaskBorderColor = (color, level) => {
    const rgb = hexToRgb(color);
    if (!rgb) return 'rgba(200, 200, 200, 0.3)';
    const borderOpacity = Math.min(0.2 + (level * 0.1), 0.8);
    return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${borderOpacity})`;
  };

  // æ—¥æ™‚ã‚’ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆã™ã‚‹é–¢æ•°
  const formatDateTime = (dateString) => {
    if (!dateString) return '';
    try {
      const d = new Date(dateString);
      if (isNaN(d.getTime())) return '';
      const month = d.getMonth() + 1;
      const day = d.getDate();
      const hours = d.getHours();
      const minutes = d.getMinutes().toString().padStart(2, '0');
      return `${month}/${day} ${hours}:${minutes}`;
    } catch (error) {
      console.error("Error formatting date time:", error, "Input was:", dateString);
      return '';
    }
  };

  // 2ã¤ã®æ—¥æ™‚ã®æ™‚é–“å·®ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°
  const calculateTimeDifference = (startDateString, endDateString) => {
    if (!startDateString || !endDateString) return '';
    try {
      const start = new Date(startDateString);
      const end = new Date(endDateString);
      if (isNaN(start.getTime()) || isNaN(end.getTime())) return '';

      const diffMs = Math.abs(end - start);

      const diffMinutes = Math.floor(diffMs / (1000 * 60));
      const diffHours = Math.floor(diffMinutes / 60);
      const diffDays = Math.floor(diffHours / 24);

      if (diffDays > 0) {
        return `${diffDays}æ—¥${diffHours % 24}æ™‚é–“`;
      } else if (diffHours > 0) {
        return `${diffHours}æ™‚é–“${diffMinutes % 60}åˆ†`;
      } else if (diffMinutes > 0) {
        return `${diffMinutes}åˆ†`;
      } else {
        return '1åˆ†æœªæº€';
      }
    } catch (error) {
      console.error("Error calculating time difference:", error);
      return '';
    }
  };

  // å…¨ã¦ã®ã‚¿ã‚¹ã‚¯ã‚’ãƒ•ãƒ©ãƒƒãƒˆãªé…åˆ—ã¨ã—ã¦å–å¾—ã™ã‚‹é–¢æ•° (å±•é–‹ã•ã‚Œã¦ã„ã‚‹ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã®ã¿)
  const getAllTasksFlat = useCallback(() => {
    const flatTasks = [];
    const flatten = (taskList) => {
      taskList.forEach(task => {
        flatTasks.push(task);
        if (task.subtasks && task.subtasks.length > 0 && expandedTasks.has(task.id)) {
          flatten(task.subtasks);
        }
      });
    };
    flatten(tasks);
    return flatTasks;
  }, [tasks, expandedTasks]);

  // é›†ä¸­ãƒ¢ãƒ¼ãƒ‰æ™‚ã«è¡¨ç¤ºã™ã‚‹ã‚¿ã‚¹ã‚¯ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã™ã‚‹é–¢æ•°
  const getFilteredTasksForFocusMode = useCallback(() => {
    if (!isFocusMode || !selectedTaskId) {
      return tasks;
    }
    const findTaskAndItsRootParent = (taskList, targetId, path = []) => {
        for (let i = 0; i < taskList.length; i++) {
          const task = taskList[i];
          const currentPath = [...path, task];
          if (task.id === targetId) {
            return currentPath[0];
          }
          if (task.subtasks && task.subtasks.length > 0) {
            const foundRoot = findTaskAndItsRootParent(task.subtasks, targetId, currentPath);
            if (foundRoot) {
              return foundRoot;
            }
          }
        }
        return null;
    };
    const rootParentOfSelected = findTaskAndItsRootParent(tasks, selectedTaskId);
    if (rootParentOfSelected) {
        return [rootParentOfSelected];
    }
    return tasks;
  }, [isFocusMode, selectedTaskId, tasks]);

  // Helper to get the full path of a task's title including its ancestors
  const getTaskPath = useCallback((taskId) => {
    const path = [];
    const findPath = (currentTasks, targetId) => {
      for (const task of currentTasks) {
        if (task.id === targetId) {
          path.unshift(task.title);
          return true;
        }
        if (task.subtasks && task.subtasks.length > 0) {
          if (findPath(task.subtasks, targetId)) {
            path.unshift(task.title);
            return true;
          }
        }
      }
      return false;
    };
    findPath(tasks, taskId);
    return path.join(' > ');
  }, [tasks]);

  // Helper to find a task's parent ID
  const findParentId = useCallback((taskIdToFind, currentTasks, parentId = null) => {
    for (const task of currentTasks) {
      if (task.id === taskIdToFind) {
        return parentId;
      }
      if (task.subtasks && task.subtasks.length > 0) {
        const foundParentId = findParentId(taskIdToFind, task.subtasks, task.id);
        if (foundParentId !== null) {
          return foundParentId;
        }
      }
    }
    return null;
  }, []);


  // ã‚¿ã‚¹ã‚¯ã®éšŽå±¤ã‚’1ã¤ä¸‹ã’ã‚‹é–¢æ•°
  const moveTaskDown = useCallback((taskId) => {
    const findAndMoveTask = (taskList) => {
      for (let i = 0; i < taskList.length; i++) {
        const task = taskList[i];
        if (task.id === taskId) {
          if (i > 0) {
            const prevSibling = taskList[i - 1];
            const taskToMove = { ...task };
            const newTaskList = [...taskList];
            newTaskList.splice(i, 1);
            const updatedPrevSibling = {
              ...prevSibling,
              subtasks: [...(prevSibling.subtasks || []), taskToMove]
            };
            newTaskList[i - 1] = updatedPrevSibling;
            setExpandedTasks(prev => new Set([...prev, prevSibling.id]));
            showNotification('ðŸ“¥ éšŽå±¤ã‚’ä¸‹ã’ã¾ã—ãŸ');
            return newTaskList;
          }
          return taskList;
        }
        if (task.subtasks && task.subtasks.length > 0) {
          const updatedSubtasks = findAndMoveTask(task.subtasks);
          if (updatedSubtasks !== task.subtasks) {
            return taskList.map(t =>
              t.id === task.id ? { ...t, subtasks: updatedSubtasks } : t
            );
          }
        }
      }
      return taskList;
    };
    setTasks(prev => findAndMoveTask(prev));
  }, [setTasks, setExpandedTasks, showNotification]);

  // ã‚¿ã‚¹ã‚¯ã®éšŽå±¤ã‚’1ã¤ä¸Šã’ã‚‹é–¢æ•°
  const moveTaskUp = useCallback((taskId) => {
    let taskMoved = false;
    const processTaskList = (taskList, parentTask = null, parentList = null, parentIndexInParentList = -1) => {
        for (let i = 0; i < taskList.length; i++) {
          const task = taskList[i];
          if (task.id === taskId) {
            if (!parentTask) {
              showNotification('âš ï¸ ã“ã‚Œä»¥ä¸ŠéšŽå±¤ã‚’ä¸Šã’ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');
              return taskList;
            }
            const taskToMove = { ...task };
            const newCurrentSubtasks = taskList.filter(t => t.id !== taskId);
            if (parentList && parentIndexInParentList !== -1) {
              parentList.splice(parentIndexInParentList + 1, 0, taskToMove);
              taskMoved = true;
              showNotification('ðŸ“¤ éšŽå±¤ã‚’ä¸Šã’ã¾ã—ãŸ');
              parentList[parentIndexInParentList] = {
                ...parentTask,
                subtasks: newCurrentSubtasks
              };
              return parentList;
            }
            return taskList;
          }
          if (task.subtasks && task.subtasks.length > 0) {
            const result = processTaskList(task.subtasks, task, taskList, i);
            if (taskMoved) {
              if (result !== task.subtasks && !parentList) { return result; }
              if (result !== task.subtasks && parentList) { return result; }
              if (result !== task.subtasks) {
                  return taskList.map(t => t.id === task.id ? {...t, subtasks: result} : t);
              }
            }
          }
        }
        return taskList;
    };
    setTasks(prevTasks => {
        const clonedTasks = JSON.parse(JSON.stringify(prevTasks));
        const updatedTasks = processTaskList(clonedTasks);
        return taskMoved ? updatedTasks : prevTasks;
    });
  }, [setTasks, showNotification]);


  // ã‚¿ã‚¹ã‚¯ã‚’åž‚ç›´æ–¹å‘ã«ç§»å‹•ã™ã‚‹é–¢æ•° (å…„å¼Ÿã‚¿ã‚¹ã‚¯é–“ã§ã®é †åºå¤‰æ›´ã€å¾ªç’°ã‚ã‚Š)
  const moveTaskVertically = useCallback((taskId, direction) => {
    let taskMoved = false;

    const moveInList = (taskList) => {
      const taskIndex = taskList.findIndex(t => t.id === taskId);
      if (taskIndex === -1) { // ã‚¿ã‚¹ã‚¯ãŒç¾åœ¨ã®ãƒªã‚¹ãƒˆã«ãªã„å ´åˆ
        // ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’å†å¸°çš„ã«æ¤œç´¢
        return taskList.map(task => {
          if (task.subtasks && task.subtasks.length > 0) {
            const updatedSubtasks = moveInList(task.subtasks);
            if (updatedSubtasks !== task.subtasks) { // ã‚µãƒ–ã‚¿ã‚¹ã‚¯å†…ã§ç§»å‹•ãŒã‚ã£ãŸå ´åˆ
              taskMoved = true; // taskMovedãƒ•ãƒ©ã‚°ã‚’ä¼æ’­ã•ã›ã‚‹
              return { ...task, subtasks: updatedSubtasks };
            }
          }
          return task;
        });
      }

      // ã‚¿ã‚¹ã‚¯ãŒç¾åœ¨ã®ãƒªã‚¹ãƒˆã§è¦‹ã¤ã‹ã£ãŸå ´åˆ
      const currentTask = taskList[taskIndex];
      const newList = [...taskList];
      newList.splice(taskIndex, 1); // ä¸€æ—¦ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤

      if (direction === 'up') {
        const newIndex = taskIndex === 0 ? newList.length : taskIndex - 1;
        newList.splice(newIndex, 0, currentTask);
        showNotification(taskIndex === 0 ? 'ðŸ”ƒ ã‚¿ã‚¹ã‚¯ã‚’ä¸€ç•ªä¸‹ã«ç§»å‹•ã—ã¾ã—ãŸ' : 'â¬†ï¸ ã‚¿ã‚¹ã‚¯ã‚’ä¸Šã«ç§»å‹•ã—ã¾ã—ãŸ');
      } else { // 'down'
        const newIndex = taskIndex === taskList.length - 1 ? 0 : taskIndex + 1;
        newList.splice(newIndex, 0, currentTask);
        showNotification(taskIndex === taskList.length - 1 ? 'ðŸ”ƒ ã‚¿ã‚¹ã‚¯ã‚’ä¸€ç•ªä¸Šã«ç§»å‹•ã—ã¾ã—ãŸ' : 'â¬‡ï¸ ã‚¿ã‚¹ã‚¯ã‚’ä¸‹ã«ç§»å‹•ã—ã¾ã—ãŸ');
      }
      taskMoved = true;
      return newList;
    };

    setTasks(prevTasks => {
      const updatedTasks = moveInList(prevTasks);
      if (taskMoved) {
        setSelectedTaskId(taskId); // ç§»å‹•å¾Œã‚‚é¸æŠžçŠ¶æ…‹ã‚’ç¶­æŒ
        setTimeout(() => {
          const movedElement = document.querySelector(`[data-task-id="${taskId}"]`);
          if (movedElement) {
            movedElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }, 50);
      }
      return updatedTasks;
    });
  }, [setTasks, setSelectedTaskId, showNotification]);


  // ã‚¿ã‚¹ã‚¯ã‚’ä¸€ç•ªä¸Šã«æŒã£ã¦ãã‚‹é–¢æ•°
  const moveTaskToTop = useCallback((taskId) => {
    let taskMoved = false;
    const processList = (currentList) => {
      const taskIndex = currentList.findIndex(t => t.id === taskId);
      if (taskIndex !== -1) {
        if (taskIndex === 0) {
          showNotification('â„¹ï¸ ã‚¿ã‚¹ã‚¯ã¯ã™ã§ã«ä¸€ç•ªä¸Šã ã‚ˆï¼');
          return currentList;
        }
        const taskToMove = currentList[taskIndex];
        const newList = [...currentList];
        newList.splice(taskIndex, 1);
        newList.unshift(taskToMove);
        taskMoved = true;
        showNotification('â¬†ï¸ ã‚¿ã‚¹ã‚¯ã‚’ä¸€ç•ªä¸Šã«ç§»å‹•ã—ãŸã‚ˆï¼');
        setSelectedTaskId(taskId);
        return newList;
      }
      return currentList.map(task => {
        if (task.subtasks && task.subtasks.length > 0) {
          const updatedSubtasks = processList(task.subtasks);
          if (updatedSubtasks !== task.subtasks) {
              taskMoved = true;
              return { ...task, subtasks: updatedSubtasks };
          }
        }
        return task;
      });
    };
    setTasks(prevTasks => {
      const updatedTasks = processList(prevTasks);
      if (taskMoved) {
        setTimeout(() => {
          const movedElement = document.querySelector(`[data-task-id="${taskId}"]`);
          if (movedElement) {
            movedElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }, 50);
      }
      return updatedTasks;
    });
  }, [setTasks, setSelectedTaskId, showNotification]);

  // ã‚¿ã‚¹ã‚¯ã‚’ä¸€ç•ªä¸‹ã«æŒã£ã¦ãã‚‹é–¢æ•°
  const moveTaskToBottom = useCallback((taskId) => {
    let taskMoved = false;
    const processList = (currentList) => {
      const taskIndex = currentList.findIndex(t => t.id === taskId);
      if (taskIndex !== -1) {
        if (taskIndex === currentList.length - 1) {
          showNotification('â„¹ï¸ ã‚¿ã‚¹ã‚¯ã¯ã™ã§ã«ä¸€ç•ªä¸‹ã ã‚ˆï¼');
          return currentList; // Already at the bottom
        }
        const taskToMove = currentList[taskIndex];
        const newList = [...currentList];
        newList.splice(taskIndex, 1); // Remove from current position
        newList.push(taskToMove); // Add to the end
        taskMoved = true;
        showNotification('â¬‡ï¸ ã‚¿ã‚¹ã‚¯ã‚’ä¸€ç•ªä¸‹ã«ç§»å‹•ã—ãŸã‚ˆï¼');
        setSelectedTaskId(taskId);
        return newList;
      }
      return currentList.map(task => {
        if (task.subtasks && task.subtasks.length > 0) {
          const updatedSubtasks = processList(task.subtasks);
          if (updatedSubtasks !== task.subtasks) {
            taskMoved = true;
            return { ...task, subtasks: updatedSubtasks };
          }
        }
        return task;
      });
    };
    setTasks(prevTasks => {
      const updatedTasks = processList(prevTasks);
      if (taskMoved) {
        setTimeout(() => {
          const movedElement = document.querySelector(`[data-task-id="${taskId}"]`);
          if (movedElement) {
            movedElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }, 50);
      }
      return updatedTasks;
    });
  }, [setTasks, setSelectedTaskId, showNotification]);


  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã§ã®é¸æŠžç§»å‹•
  const moveSelection = useCallback((direction) => {
    const flatTasks = getAllTasksFlat();
    if (direction === 'down') {
      if (!selectedTaskId && !isEmptyAreaSelected) {
        if (flatTasks.length > 0) {
          setSelectedTaskId(flatTasks[0].id);
          setIsEmptyAreaSelected(false);
        } else {
          setIsEmptyAreaSelected(true);
        }
        return;
      }
      if (isEmptyAreaSelected) {
        if (flatTasks.length > 0) {
          setSelectedTaskId(flatTasks[0].id);
          setIsEmptyAreaSelected(false);
        }
        return;
      }
      if (selectedTaskId) {
        const currentIndex = flatTasks.findIndex(task => task.id === selectedTaskId);
        if (currentIndex < flatTasks.length - 1) {
          setSelectedTaskId(flatTasks[currentIndex + 1].id);
        } else {
          setSelectedTaskId(null);
          setIsEmptyAreaSelected(true);
        }
      }
    } else { // 'up'
      if (isEmptyAreaSelected) {
        if (flatTasks.length > 0) {
          setSelectedTaskId(flatTasks[flatTasks.length - 1].id);
          setIsEmptyAreaSelected(false);
        }
        return;
      }
      if (!selectedTaskId) {
        if (tasks.length > 0) {
            setIsEmptyAreaSelected(true);
        }
        return;
      }
      if (selectedTaskId) {
        const currentIndex = flatTasks.findIndex(task => task.id === selectedTaskId);
        if (currentIndex > 0) {
          setSelectedTaskId(flatTasks[currentIndex - 1].id);
        } else {
          setSelectedTaskId(null);
          setIsEmptyAreaSelected(true);
        }
      }
    }
    setTimeout(() => {
      if (selectedTaskId) {
        const selectedElement = document.querySelector(`[data-task-id="${selectedTaskId}"]`);
        if (selectedElement) {
          selectedElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      } else if (isEmptyAreaSelected) {
        const emptyArea = document.querySelector('[data-empty-area="true"]');
        if (emptyArea) {
          emptyArea.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }
    }, 50);
  }, [getAllTasksFlat, selectedTaskId, isEmptyAreaSelected, setSelectedTaskId, setIsEmptyAreaSelected, tasks.length]);

  // ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹é–¢æ•°
  const exportData = useCallback(async (format = 'json') => {
    setExportInProgress(true);
    try {
        let dataToCopy = '';
        const filterCompletedTasks = (taskList) => {
          return taskList.filter(task => !task.completed)
            .map(task => ({
              ...task,
              subtasks: task.subtasks ? filterCompletedTasks(task.subtasks) : []
            }));
        };
        const nonCompletedTasks = filterCompletedTasks(tasks);

        if (format === 'json') {
          dataToCopy = JSON.stringify({ tasks: nonCompletedTasks, expandedTasks: Array.from(expandedTasks) }, null, 2);
          setExportedData(dataToCopy);
          showNotification('ðŸ“¤ JSONå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†ï¼');
        } else if (format === 'text') {
          const convertTasksToText = (taskList, level = 0) => {
            let text = '';
            taskList.forEach(task => {
              if (task.completed) return;
              const indent = level === 0 ? '' : 'ã€€â””';
              const prefix = level > 1 ? 'ã€€'.repeat(level - 1) + 'â””' : indent;
              text += `${prefix}${task.title}\n`;
              if (task.subtasks && task.subtasks.length > 0) {
                text += convertTasksToText(task.subtasks, level + 1);
              }
            });
            return text;
          };
          dataToCopy = convertTasksToText(nonCompletedTasks);
          setExportedData(dataToCopy);
          setShowExportedData(true);
          showNotification('ðŸ“¤ ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†ï¼');
        }

        const textarea = document.createElement('textarea');
        textarea.value = dataToCopy;
        textarea.style.position = 'fixed';
        textarea.style.left = '-9999px';
        textarea.style.top = '-9999px';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        try {
          document.execCommand('copy');
        } catch (err) {
          console.error('Failed to copy text:', err);
        }
        document.body.removeChild(textarea);
        setShowExportOptions(false);
    } catch (error) {
        console.error("Export error:", error);
        showNotification('âŒ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
    } finally {
        setTimeout(() => setExportInProgress(false), 100);
    }
  }, [tasks, expandedTasks, setExportedData, setShowExportedData, showNotification, setShowExportOptions]);


  // ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã«æ–°ã—ã„IDã‚’å†å¸°çš„ã«å‰²ã‚Šå½“ã¦ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
  const assignNewIdsRecursively = useCallback((taskList) => {
    return taskList.map(task => {
      const newId = generateId();
      return {
        ...task,
        id: newId,
        memo: task.memo || '',
        emoji: task.emoji || '',
        createdAt: task.createdAt ? new Date(task.createdAt) : new Date(),
        completedAt: task.completedAt ? new Date(task.completedAt) : null,
        subtasks: task.subtasks ? assignNewIdsRecursively(task.subtasks) : []
      };
    });
  }, [generateId]);

  // LLMã‚’ä½¿ã£ã¦çµµæ–‡å­—ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
  const generateEmojiForTask = useCallback(async (taskId, taskTitle) => {
    if (!taskTitle || taskTitle.trim() === '') return;

    try {
      const promptText = `Given the task title: "${taskTitle}", suggest a single relevant emoji. Respond with only the emoji character.`;
      let chatHistory = [{ role: "user", parts: [{ text: promptText }] }];
      const payload = {
        contents: chatHistory,
        generationConfig: {
          responseMimeType: "text/plain",
        }
      };
      const apiKey = "";
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const resultText = await response.text();
      let emoji = '';
      try {
        const jsonResult = JSON.parse(resultText);
        if (jsonResult.candidates && jsonResult.candidates[0]?.content?.parts?.[0]?.text) {
          emoji = jsonResult.candidates[0].content.parts[0].text.trim();
        }
      } catch (e) {
        emoji = resultText.trim();
      }
      if (emoji && emoji !== 'null') {
        setTasks(prevTasks => {
          const updateEmojiRecursively = (taskList) => {
            return taskList.map(task => {
              if (task.id === taskId) {
                return { ...task, emoji: emoji };
              }
              if (task.subtasks && task.subtasks.length > 0) {
                return { ...task, subtasks: updateEmojiRecursively(task.subtasks) };
              }
              return task;
            });
          };
          return updateEmojiRecursively(prevTasks);
        });
      } else {
        console.warn('Emoji generation API returned empty or invalid response for:', taskTitle);
      }
    } catch (error) {
      console.error('Emoji generation API Error:', error);
    }
  }, [setTasks]);

  // ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹é–¢æ•°
  const importData = useCallback((text) => {
    const trimmedText = text.trim();
    let tasksToProcess = [];
    const collectExpandableTaskIds = (taskList) => {
      const ids = new Set();
      const traverse = (tasksToTraverse) => {
        tasksToTraverse.forEach(task => {
          if (task.subtasks && task.subtasks.length > 0) {
            ids.add(task.id);
            traverse(task.subtasks);
          }
        });
      };
      traverse(taskList);
      return ids;
    };

    if (trimmedText.startsWith('{') || trimmedText.startsWith('[')) {
      try {
        const importedData = JSON.parse(trimmedText);
        let rawTasks = [];
        if (importedData.tasks && Array.isArray(importedData.tasks)) {
            rawTasks = importedData.tasks;
        } else if (Array.isArray(importedData)) {
            rawTasks = importedData;
        } else {
            showNotification('âŒ ç„¡åŠ¹ãªJSONãƒ‡ãƒ¼ã‚¿å½¢å¼ã§ã™');
            return;
        }
        tasksToProcess = assignNewIdsRecursively(rawTasks);

        if (importedData.expandedTasks && Array.isArray(importedData.expandedTasks)) {
            const newExpanded = new Set();
            const expandParents = (taskList) => {
                taskList.forEach(task => {
                    if (task.subtasks && task.subtasks.length > 0) {
                        newExpanded.add(task.id);
                        expandParents(task.subtasks);
                    }
                });
            };
            expandParents(tasksToProcess);
            if (importMode === 'overwrite') {
                setExpandedTasks(newExpanded);
            } else {
                setExpandedTasks(oldExpanded => new Set([...oldExpanded, ...newExpanded]));
            }
        }


      } catch (error) {
        console.error("Error parsing JSON data:", error);
        showNotification('âŒ ç„¡åŠ¹ãªJSONãƒ‡ãƒ¼ã‚¿ã§ã™');
        return;
      }
    } else { // Text import
      try {
        const lines = trimmedText.split('\n').filter(line => line.trim());
        const newTasksFromText = [];
        const taskStack = [{ subtasks: newTasksFromText, level: -1, id: null }];

        lines.forEach(line => {
          const currentTrimmedLine = line.trim();
          if (!currentTrimmedLine) return;
          let level = 0;
          let taskTitle = currentTrimmedLine;
          if (currentTrimmedLine.startsWith('ã€€â””')) {
            level = 1;
            let currentIndent = 0;
            while(line.substring(currentIndent, currentIndent + 2) === 'ã€€â””' || line.substring(currentIndent, currentIndent + 1) === 'ã€€' || line.substring(currentIndent, currentIndent + 1) === 'â””'){
                 if(line.substring(currentIndent, currentIndent + 2) === 'ã€€â””'){ level++; currentIndent +=2; }
                 else if (line.substring(currentIndent, currentIndent + 1) === 'â””'){ level++; currentIndent +=1; }
                 else if (line.substring(currentIndent, currentIndent + 1) === 'ã€€'){ currentIndent +=1; }
                 else { break; }
            }
            taskTitle = line.substring(currentIndent).trim();
          } else if (currentTrimmedLine.startsWith('â””')) {
            level = 1;
            taskTitle = currentTrimmedLine.substring(1).trim();
          }
          while (taskStack.length > level + 1 && taskStack[taskStack.length -1].level >= level) {
              taskStack.pop();
          }
          const newTask = {
            id: generateId(), title: taskTitle, completed: false, color: colors[0],
            createdAt: new Date(), completedAt: null, subtasks: [], memo: '', emoji: ''
          };
          const parent = taskStack[taskStack.length - 1];
          if (!parent.subtasks) parent.subtasks = [];
          parent.subtasks.push(newTask);
          taskStack.push({...newTask, level: level });
        });
        tasksToProcess = newTasksFromText;
      } catch (error) {
        console.error("Error parsing text data:", error);
        showNotification('âŒ ãƒ†ã‚­ã‚¹ãƒˆã®è§£æžã«å¤±æ•—ã—ã¾ã—ãŸ');
        return;
      }
    }

    if (importMode === 'overwrite') {
      setTasks(tasksToProcess);
      const newExpanded = collectExpandableTaskIds(tasksToProcess);
      setExpandedTasks(newExpanded);
      showNotification(`ðŸ“¥ ${tasksToProcess.length}å€‹ã®ã‚¿ã‚¹ã‚¯ã‚’ä¸Šæ›¸ãã—ã¾ã—ãŸ`);
    } else { // 'add'
      setTasks(prevTasks => {
        const newTasksList = [...prevTasks, ...tasksToProcess];
        const newExpandedIds = collectExpandableTaskIds(tasksToProcess);
        setExpandedTasks(oldExpanded => new Set([...oldExpanded, ...newExpandedIds]));
        return newTasksList;
      });
      showNotification(`ðŸ“¥ ${tasksToProcess.length}å€‹ã®ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ã¾ã—ãŸ`);
    }

    const generateEmojisRecursively = (taskList) => {
      taskList.forEach(task => {
        if (task.title && task.title.trim() !== '') {
          generateEmojiForTask(task.id, task.title);
        }
        if (task.subtasks && task.subtasks.length > 0) {
          generateEmojisRecursively(task.subtasks);
        }
      });
    };
    generateEmojisRecursively(tasksToProcess);

    setShowImportArea(false);
  }, [assignNewIdsRecursively, colors, importMode, setTasks, setExpandedTasks, setShowImportArea, showNotification, generateId, generateEmojiForTask]);

  // ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã™ã‚‹é–¢æ•°
  const addTask = useCallback((parentId = null, initialTitle = '', customColor = null, insertAfterId = null, isFromShortcut = false) => {
    let title = initialTitle;
    let taskColor = newTaskColor;

    if (parentId && parentId !== 'root') {
      if (!isFromShortcut && !initialTitle) {
        const inputRef = subtaskInputRefs.current[parentId];
        if (inputRef) {
          title = inputRef.value.trim();
          if (!title) {
            showNotification('ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
            return null;
          }
          inputRef.value = '';
        }
      }
      const findParentColor = (taskListToSearch) => {
        for (let t of taskListToSearch) {
          if (t.id === parentId) return t.color;
          if (t.subtasks && t.subtasks.length > 0) {
            const foundColor = findParentColor(t.subtasks);
            if (foundColor) return foundColor;
          }
        }
        return colors[0];
      };
      taskColor = customColor || findParentColor(tasks);
    } else if (parentId === 'root') {
      if (!isFromShortcut && !initialTitle && mainInputRef.current && mainInputRef.current.value.trim()) {
        title = mainInputRef.current.value.trim();
        mainInputRef.current.value = '';
      }
      taskColor = customColor || newTaskColor;
    } else {
      taskColor = customColor || newTaskColor;
    }

    if (!title && !isFromShortcut) {
        showNotification('ã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
        return null;
    }

    const newTaskObject = {
      id: generateId(), title: title, completed: false, color: taskColor,
      createdAt: new Date(), completedAt: null, subtasks: [], memo: '', emoji: ''
    };

    if (parentId && parentId !== 'root') {
      setTasks(prev => {
        const addSubtaskRecursively = (currentTaskList) => {
          return currentTaskList.map(t => {
            if (t.id === parentId) {
              const newSubtasks = [...(t.subtasks || [])];
              if (insertAfterId) {
                const insertIndex = newSubtasks.findIndex(st => st.id === insertAfterId);
                if (insertIndex !== -1) {
                  newSubtasks.splice(insertIndex + 1, 0, newTaskObject);
                } else {
                  newSubtasks.push(newTaskObject);
                }
              } else {
                newSubtasks.push(newTaskObject);
              }
              return { ...t, subtasks: newSubtasks };
            }
            if (t.subtasks && t.subtasks.length > 0) {
              return { ...t, subtasks: addSubtaskRecursively(t.subtasks) };
            }
            return t;
          });
        };
        return addSubtaskRecursively(prev);
      });
      setExpandedTasks(prev => new Set(prev).add(parentId));
    } else {
      setTasks(prev => {
        const newRootTasks = [...prev];
        if (insertAfterId) {
          const insertIndex = newRootTasks.findIndex(t => t.id === insertAfterId);
          if (insertIndex !== -1) {
            newRootTasks.splice(insertIndex + 1, 0, newTaskObject);
          } else {
            newRootTasks.unshift(newTaskObject);
          }
        } else {
          newRootTasks.unshift(newTaskObject);
        }
        return newRootTasks;
      });
    }

    setSelectedTaskId(newTaskObject.id);
    setIsEmptyAreaSelected(false);
    setShowAddForm(null);

    if (newTaskObject.title && newTaskObject.title.trim() !== '' && !isFromShortcut) {
      generateEmojiForTask(newTaskObject.id, newTaskObject.title);
    }
    return newTaskObject;
  }, [colors, newTaskColor, tasks, setTasks, setExpandedTasks, setSelectedTaskId, setIsEmptyAreaSelected, setShowAddForm, subtaskInputRefs, mainInputRef, showNotification, generateId, generateEmojiForTask]);


  // ã‚¿ã‚¹ã‚¯ã®å®Œäº†çŠ¶æ…‹ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹é–¢æ•°
  const toggleComplete = useCallback((taskId) => {
    const updateTaskRecursively = (taskList) => {
      return taskList.map(task => {
        if (task.id === taskId) {
          const newCompleted = !task.completed;
          const completeAllSubtasks = (subtaskList) => {
            return subtaskList.map(subtask => {
              const newSubtask = { ...subtask, completed: true, completedAt: new Date() };
              if (subtask.subtasks && subtask.subtasks.length > 0) {
                newSubtask.subtasks = completeAllSubtasks(subtask.subtasks);
              }
              return newSubtask;
            });
          };
          if (newCompleted && task.subtasks && task.subtasks.length > 0) {
            showNotification('âœ… ã‚¿ã‚¹ã‚¯ã¨ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’å®Œäº†ã—ã¾ã—ãŸ');
            return {
              ...task, completed: true, completedAt: new Date(),
              subtasks: completeAllSubtasks(task.subtasks)
            };
          }
          showNotification(newCompleted ? 'âœ… ã‚¿ã‚¹ã‚¯ã‚’å®Œäº†ã—ã¾ã—ãŸ' : 'ðŸ“ æœªå®Œäº†ã«æˆ»ã—ã¾ã—ãŸ');
          return { ...task, completed: newCompleted, completedAt: newCompleted ? new Date() : null };
        }
        if (task.subtasks && task.subtasks.length > 0) {
          return { ...task, subtasks: updateTaskRecursively(task.subtasks) };
        }
        return task;
      });
    };
    setTasks(prev => updateTaskRecursively(prev));
  }, [setTasks, showNotification]);

  // ã‚¿ã‚¹ã‚¯ã®è‰²ã‚’å¤‰æ›´ã™ã‚‹é–¢æ•°
  const changeTaskColor = useCallback((taskId, newColor) => {
    const updateTaskRecursively = (taskList) => {
      return taskList.map(task => {
        if (task.id === taskId) {
          return { ...task, color: newColor };
        }
        if (task.subtasks && task.subtasks.length > 0) {
          return { ...task, subtasks: updateTaskRecursively(task.subtasks) };
        }
        return task;
      });
    };
    setTasks(prev => updateTaskRecursively(prev));
    setShowColorPicker(null);
    showNotification('ðŸŽ¨ è‰²ã‚’å¤‰æ›´ã—ã¾ã—ãŸ');
  }, [setTasks, setShowColorPicker, showNotification]);

  // Helper to find a task's location
  const findTaskLocation = useCallback((taskList, targetId, currentParentId = null) => {
    for (let i = 0; i < taskList.length; i++) {
      const task = taskList[i];
      if (task.id === targetId) {
        return { task, parentId: currentParentId, originalIndex: i };
      }
      if (task.subtasks && task.subtasks.length > 0) {
        const found = findTaskLocation(task.subtasks, targetId, task.id);
        if (found) return found;
      }
    }
    return null;
  }, []);

  // ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã™ã‚‹é–¢æ•°
  const deleteTask = useCallback((taskId) => {
    if (undoNotificationTimerRef.current) {
      clearTimeout(undoNotificationTimerRef.current);
    }
    setTasks(prevTasks => {
      const location = findTaskLocation(prevTasks, taskId);
      let deletedTask = null, parentId = null, originalIndex = -1;
      if (location) {
        ({ task: deletedTask, parentId, originalIndex } = location);
      }
      const removeTaskRecursively = (currentTaskList) => {
        return currentTaskList.filter(task => {
          if (task.id === taskId) return false;
          if (task.subtasks && task.subtasks.length > 0) {
            task.subtasks = removeTaskRecursively(task.subtasks);
          }
          return true;
        });
      };
      const updatedTasks = removeTaskRecursively(prevTasks);
      if (deletedTask) {
        setLastDeletedTaskInfo({ task: deletedTask, parentId, originalIndex });
        showNotification('ðŸ—‘ï¸ ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚');
        undoNotificationTimerRef.current = setTimeout(() => {
          setLastDeletedTaskInfo(null);
          setNotification('');
        }, 5000);
      }
      if (selectedTaskId === taskId) setSelectedTaskId(null);
      return updatedTasks;
    });
  }, [setTasks, selectedTaskId, setSelectedTaskId, showNotification, findTaskLocation]);

  // å®Œäº†æ¸ˆã¿ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿéš›ã«å‰Šé™¤ã™ã‚‹å‡¦ç†
  const executeDeleteCompletedTasks = useCallback(() => {
    const removeCompletedRecursively = (taskList) => {
      return taskList
        .map(task => {
          if (task.subtasks && task.subtasks.length > 0) {
            const updatedSubtasks = removeCompletedRecursively(task.subtasks);
            return { ...task, subtasks: updatedSubtasks };
          }
          return task;
        })
        .filter(task => !task.completed);
    };

    setTasks(prevTasks => {
      const originalTaskCount = getAllTasksFlat().length; // å‰Šé™¤å‰ã®ç·ã‚¿ã‚¹ã‚¯æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
      const updatedTasks = removeCompletedRecursively(prevTasks);
      const finalTaskCount = updatedTasks.reduce((acc, task) => acc + 1 + (task.subtasks ? task.subtasks.length : 0), 0);


      const remainingTaskIds = new Set();
      const collectIds = (ts) => {
        ts.forEach(t => {
          remainingTaskIds.add(t.id);
          if (t.subtasks) collectIds(t.subtasks);
        });
      };
      collectIds(updatedTasks);
      setExpandedTasks(currentExpanded => new Set([...currentExpanded].filter(id => remainingTaskIds.has(id))));

      if (finalTaskCount < originalTaskCount) {
          showNotification('ðŸ§¹ å®Œäº†æ¸ˆã¿ã®ã‚¿ã‚¹ã‚¯ã‚’ä¸€æ‹¬å‰Šé™¤ã—ã¾ã—ãŸã€‚');
      } else {
          showNotification('â„¹ï¸ å‰Šé™¤å¯¾è±¡ã®å®Œäº†æ¸ˆã¿ã‚¿ã‚¹ã‚¯ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚');
      }
      return updatedTasks;
    });
    setShowDeleteCompletedConfirmModal(false);
  }, [setTasks, setExpandedTasks, showNotification, getAllTasksFlat]); // getAllTasksFlat ã‚’ä¾å­˜é…åˆ—ã«è¿½åŠ 

  // ã€Œå®Œäº†æ¸ˆã¿ã®ã‚¿ã‚¹ã‚¯å‰Šé™¤ã€ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã¨ãã®å‡¦ç†ï¼ˆç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºï¼‰
  const handleDeleteCompletedTasks = useCallback(() => {
    const completedTasksExist = tasks.some(task => {
      const checkCompleted = (t) => {
          if (t.completed) return true;
          if (t.subtasks && t.subtasks.some(st => checkCompleted(st))) return true;
          return false;
      }
      return checkCompleted(task);
    });

    if (completedTasksExist) {
        setShowDeleteCompletedConfirmModal(true);
    } else {
        showNotification('â„¹ï¸ å‰Šé™¤å¯¾è±¡ã®å®Œäº†æ¸ˆã¿ã‚¿ã‚¹ã‚¯ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚');
    }
  }, [tasks, showNotification]);


  // å‰Šé™¤ã‚’å…ƒã«æˆ»ã™é–¢æ•°
  const undoDelete = useCallback(() => {
    if (!lastDeletedTaskInfo || !lastDeletedTaskInfo.task) {
      showNotification('å…ƒã«æˆ»ã›ã‚‹ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
      return;
    }
    const { task, parentId, originalIndex } = lastDeletedTaskInfo;
    setTasks(prevTasks => {
      const newTasks = JSON.parse(JSON.stringify(prevTasks));
      if (parentId === null) {
        newTasks.splice(originalIndex, 0, task);
      } else {
        const findAndInsert = (currentTaskList) => {
          for (let i = 0; i < currentTaskList.length; i++) {
            const currentTask = currentTaskList[i];
            if (currentTask.id === parentId) {
              if (!currentTask.subtasks) currentTask.subtasks = [];
              const insertIndex = Math.min(originalIndex, currentTask.subtasks.length);
              currentTask.subtasks.splice(insertIndex, 0, task);
              setExpandedTasks(prev => new Set(prev).add(parentId));
              return true;
            }
            if (currentTask.subtasks && currentTask.subtasks.length > 0) {
              if (findAndInsert(currentTask.subtasks)) return true;
            }
          }
          return false;
        };
        findAndInsert(newTasks);
      }
      return newTasks;
    });
    setLastDeletedTaskInfo(null);
    if (undoNotificationTimerRef.current) clearTimeout(undoNotificationTimerRef.current);
    showNotification('â†©ï¸ ã‚¿ã‚¹ã‚¯ã‚’å…ƒã«æˆ»ã—ã¾ã—ãŸï¼');
    setSelectedTaskId(task.id);
  }, [lastDeletedTaskInfo, setTasks, setExpandedTasks, showNotification, setSelectedTaskId]);

  // ã‚¿ã‚¹ã‚¯ã®ç·¨é›†ã‚’é–‹å§‹ã™ã‚‹é–¢æ•°
  const startEditTask = useCallback((taskId) => {
    setEditingTask(taskId);
  }, [setEditingTask]);

  // ã‚¿ã‚¹ã‚¯ã®ç·¨é›†ã‚’çµ‚äº†ã™ã‚‹é–¢æ•°
  const finishEditTask = useCallback((taskId) => {
    const editInput = editInputRefs.current[taskId];
    if (!editInput) return;
    const newTitle = editInput.value.trim();
    if (!newTitle) {
      setEditingTask(null);
      return;
    }
    const updateTaskRecursively = (taskList) => {
      return taskList.map(task => {
        if (task.id === taskId) {
          return { ...task, title: newTitle };
        }
        if (task.subtasks && task.subtasks.length > 0) {
          return { ...task, subtasks: updateTaskRecursively(task.subtasks) };
        }
        return task;
      });
    };
    setTasks(prev => {
      const updatedTasks = updateTaskRecursively(prev);
      const oldTask = getAllTasksFlat().find(t => t.id === taskId);
      if (oldTask && newTitle !== oldTask.title) {
        generateEmojiForTask(taskId, newTitle);
      }
      return updatedTasks;
    });
    setEditingTask(null);
    showNotification('âœï¸ æ›´æ–°ã—ã¾ã—ãŸ');
  }, [setTasks, setEditingTask, showNotification, getAllTasksFlat, generateEmojiForTask]);

  // ã‚¿ã‚¹ã‚¯ã®å±•é–‹/æŠ˜ã‚ŠãŸãŸã¿ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹é–¢æ•°
  const toggleExpanded = useCallback((taskId) => {
    setExpandedTasks(prev => {
      const newSet = new Set(prev);
      if (newSet.has(taskId)) newSet.delete(taskId);
      else newSet.add(taskId);
      return newSet;
    });
  }, [setExpandedTasks]);

  // é€²æ—çŠ¶æ³ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°
  const calculateStats = useCallback(() => {
    const getAll = (taskList) => {
      let all = [];
      taskList.forEach(task => {
        all.push(task);
        if (task.subtasks && task.subtasks.length > 0) {
          all = all.concat(getAll(task.subtasks));
        }
      });
      return all;
    };
    const allCurrentTasks = getAll(tasks);
    const completed = allCurrentTasks.filter(t => t.completed).length;
    const total = allCurrentTasks.length;
    const progress = total > 0 ? (completed / total) * 100 : 0;
    return { completed, total, progress, inProgress: total - completed };
  }, [tasks]);


  // openMemoModal é–¢æ•°ã®å®šç¾©
  const openMemoModal = useCallback((task) => {
    if (task && typeof task.id !== 'undefined') {
      setShowMemoModal(task.id);
      setCurrentMemo(task.memo || '');
    } else {
      console.error("openMemoModal: Invalid task object or task.id is undefined", task);
      showNotification("ãƒ¡ãƒ¢ã‚’é–‹ã‘ã¾ã›ã‚“ã§ã—ãŸã€‚ã‚¿ã‚¹ã‚¯æƒ…å ±ãŒä¸å‚™ã§ã™ã€‚");
    }
  }, [setShowMemoModal, setCurrentMemo, showNotification]);

  // saveMemo é–¢æ•°ã®å®šç¾©
  const saveMemo = useCallback((taskId, newMemo) => {
    const updateTaskRecursively = (taskList) => {
      return taskList.map(task => {
        if (task.id === taskId) {
          return { ...task, memo: newMemo };
        }
        if (task.subtasks && task.subtasks.length > 0) {
          return { ...task, subtasks: updateTaskRecursively(task.subtasks) };
        }
        return task;
      });
    };
    setTasks(prev => updateTaskRecursively(prev));
    setShowMemoModal(null);
    setCurrentMemo('');
    showNotification('ðŸ“ ãƒ¡ãƒ¢ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
  }, [setTasks, setShowMemoModal, setCurrentMemo, showNotification]);


  // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã®ä½ç½®ã‚’è¨ˆç®—ã™ã‚‹useEffect
  useEffect(() => {
    const calculatePosition = () => {
      if (showExportOptions && exportButtonRef.current) {
        const rect = exportButtonRef.current.getBoundingClientRect();
        setExportDropdownPosition({ top: rect.bottom + 8, left: rect.right });
      }
    };
    calculatePosition();
    window.addEventListener('resize', calculatePosition);
    return () => window.removeEventListener('resize', calculatePosition);
  }, [showExportOptions]);

  // editingTaskãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãã«ã€å¯¾å¿œã™ã‚‹å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’å½“ã¦ã‚‹useEffect
  useEffect(() => {
    if (editingTask) {
      const taskBeingEdited = getAllTasksFlat().find(task => task.id === editingTask);
      if (taskBeingEdited) {
        const inputElement = editInputRefs.current[editingTask];
        if (inputElement) {
          inputElement.value = taskBeingEdited.title;
          inputElement.focus();
          inputElement.select();
        } else {
          const retryFocusTimeout = setTimeout(() => {
            if (editingTaskRef.current === editingTask) {
                setEditingTask(null);
                setTimeout(()=> setEditingTask(editingTask),0);
            }
          }, 50);
          return () => clearTimeout(retryFocusTimeout);
        }
      }
    }
  }, [editingTask, getAllTasksFlat]);

  // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
  useEffect(() => {
    const handleGlobalKeyDown = (e) => {
      const isInInputField = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
      const isModalOpen = showColorPicker || showNewTaskColorPicker || showMemoModal || showExportOptions || showDeleteCompletedConfirmModal;


      if (e.key === 'Escape') {
        setShowColorPicker(null); setShowNewTaskColorPicker(false); setShowExportedData(false);
        setShowExportOptions(false); setEditingTask(null); if (showAddForm) setShowAddForm(null);
        setSelectedTaskId(null); setIsEmptyAreaSelected(false); setNotification('');
        setLastDeletedTaskInfo(null); if (undoNotificationTimerRef.current) clearTimeout(undoNotificationTimerRef.current);
        if (showMemoModal) { setShowMemoModal(null); setCurrentMemo(''); }
        if (showDeleteCompletedConfirmModal) setShowDeleteCompletedConfirmModal(false);
        return;
      }

      if (isModalOpen && e.key !== 'Escape') { // ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºä¸­ã¯Escapeä»¥å¤–ã®ã‚­ãƒ¼æ“ä½œã‚’åˆ¶é™ï¼ˆã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ã®å·¦å³ã‚­ãƒ¼ã¯ä¾‹å¤–ï¼‰
        if (showColorPicker && (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'Enter')) {
            // ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼å†…ã®æ“ä½œã¯è¨±å¯
        } else if (showMemoModal && e.ctrlKey && e.key === 'Enter') {
            // ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ€ãƒ«ã§ã®Ctrl+Enterã¯è¨±å¯ (ã™ã§ã«textareaã®onKeyDownã§å‡¦ç†ã•ã‚Œã‚‹ãŸã‚ã€ã“ã“ã§ã¯ä½•ã‚‚ã—ãªã„)
        }
        else {
            return;
        }
      }


      if (e.key === 'Tab') {
        if (editingTask || selectedTaskId) {
          e.preventDefault();
          const targetTaskId = editingTask || selectedTaskId;
          if (e.shiftKey) moveTaskUp(targetTaskId);
          else moveTaskDown(targetTaskId);
          return;
        }
      }
      if (e.shiftKey && e.altKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
        if (editingTask || selectedTaskId) {
          e.preventDefault();
          const targetTaskId = editingTask || selectedTaskId;
          moveTaskVertically(targetTaskId, e.key === 'ArrowUp' ? 'up' : 'down');
          return;
        }
      }
      if (e.key === 'F2') {
        if (selectedTaskId) {
          e.preventDefault();
          const taskToMemo = getAllTasksFlat().find(task => task.id === selectedTaskId);
          if (taskToMemo) openMemoModal(taskToMemo);
        }
        return;
      }

      if (showColorPicker) {
        e.preventDefault();
        if (e.key === 'ArrowLeft') setSelectedColorIndex(prev => prev > 0 ? prev - 1 : colors.length - 1);
        else if (e.key === 'ArrowRight') setSelectedColorIndex(prev => prev < colors.length - 1 ? prev + 1 : 0);
        else if (e.key === 'Enter') changeTaskColor(showColorPicker, colors[selectedColorIndex]);
        return;
      }

      if (!isInInputField) {
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
          e.preventDefault();
          moveSelection(e.key === 'ArrowUp' ? 'up' : 'down');
        }
        if (e.ctrlKey && (e.key === 'u' || e.key === 'U')) {
          e.preventDefault();
          if (selectedTaskId) moveTaskToTop(selectedTaskId);
          else showNotification('âš ï¸ ã¾ãšã‚¿ã‚¹ã‚¯ã‚’é¸ã‚“ã§ã­ï¼');
          return;
        }
        // Ctrl+D ã§ã‚¿ã‚¹ã‚¯ã‚’ä¸€ç•ªä¸‹ã«ç§»å‹•
        if (e.ctrlKey && (e.key === 'd' || e.key === 'D')) {
          e.preventDefault();
          if (selectedTaskId) moveTaskToBottom(selectedTaskId);
          else showNotification('âš ï¸ ã¾ãšã‚¿ã‚¹ã‚¯ã‚’é¸ã‚“ã§ã­ï¼');
          return;
        }
        if (e.ctrlKey && e.shiftKey && e.key === 'Enter') {
          e.preventDefault();
          let newParentId = null, insertAfterId = null;
          if (selectedTaskId) {
            newParentId = findParentId(selectedTaskId, tasks);
            insertAfterId = selectedTaskId;
          }
          const newTask = addTask(newParentId, '', null, insertAfterId, true);
          if (newTask) startEditTask(newTask.id);
          return;
        }
        if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey) {
          e.preventDefault();
          if (selectedTaskId) {
              setShowAddForm(selectedTaskId);
              setTimeout(() => {
                const inputRef = subtaskInputRefs.current[selectedTaskId];
                if (inputRef) inputRef.focus();
              }, 100);
          } else if (tasks.length === 0 || isEmptyAreaSelected) {
            const newTask = addTask('root', '', null, null, true);
            if (newTask) startEditTask(newTask.id);
          }
          return;
        }
        if (e.key === 'Enter' && e.shiftKey && !e.ctrlKey) {
            e.preventDefault();
            const newTask = addTask('root', '', null, null, true);
            if (newTask) startEditTask(newTask.id);
            return;
        }
        if (e.key === 'Enter' && e.ctrlKey && !e.shiftKey) {
            e.preventDefault();
            if(selectedTaskId) toggleComplete(selectedTaskId);
            return;
        }
        if (e.ctrlKey && (e.key === 'i' || e.key === 'I')) {
          e.preventDefault();
          if (!selectedTaskId && !isFocusMode) {
            showNotification('âš ï¸ é›†ä¸­ãƒ¢ãƒ¼ãƒ‰ã«ã™ã‚‹ã«ã¯ã€ã¾ãšã‚¿ã‚¹ã‚¯ã‚’é¸ã‚“ã§ã­ï¼');
            return;
          }
          setIsFocusMode(prev => !prev);
          showNotification(!isFocusMode ? 'ðŸŽ¯ é›†ä¸­ãƒ¢ãƒ¼ãƒ‰ã«ãªã£ãŸã‚ˆï¼' : 'ðŸ‘€ ã‚¿ã‚¹ã‚¯ç¢ºèªãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã£ãŸã‚ˆï¼');
          return;
        }
        if (e.ctrlKey && (e.key === 'c' || e.key === 'C')) {
          e.preventDefault();
          if (selectedTaskId) {
            const taskToColor = getAllTasksFlat().find(task => task.id === selectedTaskId);
            if (taskToColor) {
              const currentColorIndex = colors.findIndex(color => color === taskToColor.color);
              setSelectedColorIndex(currentColorIndex !== -1 ? currentColorIndex : 0);
              setShowColorPicker(selectedTaskId);
            }
          } else {
            showNotification('âš ï¸ ã¾ãšã‚¿ã‚¹ã‚¯ã‚’é¸ã‚“ã§ã­ï¼');
          }
          return;
        }
        if (selectedTaskId) {
          if (e.key === ' ') {
            e.preventDefault();
            const taskToEdit = getAllTasksFlat().find(task => task.id === selectedTaskId);
            if (taskToEdit) startEditTask(taskToEdit.id);
          } else if (e.key === 'Delete' || e.key === 'Backspace') {
            e.preventDefault();
            deleteTask(selectedTaskId);
          }
        }
      }
    };
    document.addEventListener('keydown', handleGlobalKeyDown);
    return () => document.removeEventListener('keydown', handleGlobalKeyDown);
  }, [
    showAddForm, selectedTaskId, isEmptyAreaSelected, showColorPicker, selectedColorIndex, colors, tasks, expandedTasks,
    isFocusMode, getAllTasksFlat, startEditTask, editingTask, showMemoModal, findParentId,
    moveTaskUp, moveTaskDown, moveTaskVertically, openMemoModal, moveTaskToTop, moveTaskToBottom, // moveTaskToBottom ã‚’è¿½åŠ 
    showNotification, addTask, changeTaskColor, deleteTask, finishEditTask,
    setShowColorPicker, setShowNewTaskColorPicker, setShowExportedData, setShowExportOptions,
    setEditingTask, setShowAddForm, setSelectedTaskId, setIsEmptyAreaSelected, setNotification,
    setShowMemoModal, setCurrentMemo, setSelectedColorIndex, toggleComplete, moveSelection,
    setLastDeletedTaskInfo, exportInProgress, showDeleteCompletedConfirmModal
  ]);

  // LLMã‚’ä½¿ã£ã¦ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
  const generateSubtasksWithAI = async () => {
    let taskTitleToBreakdown = '';
    let parentTaskId = null;
    let contextPath = '';

    if (selectedTaskId) {
      const selectedTask = getAllTasksFlat().find(task => task.id === selectedTaskId);
      if (selectedTask) {
        taskTitleToBreakdown = selectedTask.title;
        parentTaskId = selectedTask.id;
        contextPath = getTaskPath(selectedTaskId);
      }
    } else if (tasks.length > 0) {
      const userInput = window.prompt("ã©ã®ã‚¿ã‚¹ã‚¯ã‚’åˆ†è§£ã—ã¾ã™ã‹ï¼Ÿ (ä¾‹: èª•ç”Ÿæ—¥ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¼ã®è¨ˆç”»)");
      if (!userInput) { showNotification('âš ï¸ ã‚¿ã‚¹ã‚¯ãŒå…¥åŠ›ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚'); return; }
      taskTitleToBreakdown = userInput;
      const newParentTask = addTask('root', taskTitleToBreakdown, colors[0], null, false);
      if (newParentTask) {
        parentTaskId = newParentTask.id;
        setSelectedTaskId(newParentTask.id);
        setExpandedTasks(prev => new Set([...prev, newParentTask.id]));
        contextPath = newParentTask.title;
      } else { showNotification('âŒ è¦ªã‚¿ã‚¹ã‚¯ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); return; }
    } else {
      const userInput = window.prompt("æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’åˆ†è§£ã—ã¾ã™ã‹ï¼Ÿ (ä¾‹: èª•ç”Ÿæ—¥ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¼ã®è¨ˆç”»)");
      if (!userInput) { showNotification('âš ï¸ ã‚¿ã‚¹ã‚¯ãŒå…¥åŠ›ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚'); return; }
      taskTitleToBreakdown = userInput;
      const newTask = addTask('root', taskTitleToBreakdown, colors[0], null, false);
      if (newTask) {
        parentTaskId = newTask.id;
        setSelectedTaskId(newTask.id);
        setExpandedTasks(prev => new Set([...prev, newTask.id]));
        contextPath = newTask.title;
      } else { showNotification('âŒ ã‚¿ã‚¹ã‚¯ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); return; }
    }

    if (!taskTitleToBreakdown) { showNotification('âš ï¸ åˆ†è§£ã™ã‚‹ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); return; }
    if (!parentTaskId) { showNotification('âš ï¸ ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã™ã‚‹è¦ªã‚¿ã‚¹ã‚¯ãŒç‰¹å®šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚'); return; }

    setIsGeneratingSubtasks(true);
    showNotification('âœ¨ ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆä¸­...');
    try {
      const promptText = `Given the task hierarchy: "${contextPath}", break down the task "${taskTitleToBreakdown}" into a list of actionable subtasks. Provide the response as a JSON array of strings, where each string is a subtask title. If the task is simple and doesn't require breakdown, return an empty array. Limit the number of subtasks to a maximum of 4.`;
      let chatHistory = [{ role: "user", parts: [{ text: promptText }] }];
      const payload = {
        contents: chatHistory,
        generationConfig: { responseMimeType: "application/json", responseSchema: { type: "ARRAY", items: { "type": "STRING" } } }
      };
      const apiKey = "";
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
      const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
      const result = await response.json();

      if (result.candidates && result.candidates[0]?.content?.parts?.[0]?.text) {
        const jsonString = result.candidates[0].content.parts[0].text;
        let subtasksFromAI = JSON.parse(jsonString);
        if (subtasksFromAI && Array.isArray(subtasksFromAI)) {
          if (subtasksFromAI.length > 4) {
            subtasksFromAI = subtasksFromAI.slice(0, 4);
            showNotification('â„¹ï¸ ç”Ÿæˆã•ã‚ŒãŸã‚µãƒ–ã‚¿ã‚¹ã‚¯ãŒå¤šã™ãŽãŸãŸã‚ã€æœ€åˆã®4ã¤ã«åˆ¶é™ã—ã¾ã—ãŸã€‚');
          }
        } else { subtasksFromAI = []; }

        if (subtasksFromAI.length > 0) {
          const addGeneratedSubtasks = (currentTasks, targetParentId) => {
            return currentTasks.map(task => {
              if (task.id === targetParentId) {
                const newSubtasks = subtasksFromAI.map(subtaskTitle => ({
                  id: generateId(), title: subtaskTitle, completed: false, color: '#22C55E',
                  createdAt: new Date(), completedAt: null, subtasks: [], memo: '', emoji: ''
                }));
                newSubtasks.forEach(subtask => { if (subtask.title?.trim()) generateEmojiForTask(subtask.id, subtask.title); });
                return { ...task, subtasks: [...(task.subtasks || []), ...newSubtasks] };
              }
              if (task.subtasks?.length > 0) return { ...task, subtasks: addGeneratedSubtasks(task.subtasks, targetParentId) };
              return task;
            });
          };
          setTasks(prev => addGeneratedSubtasks(prev, parentTaskId));
          setExpandedTasks(prev => new Set([...prev, parentTaskId]));
          showNotification('âœ… ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆã—ã¾ã—ãŸï¼');
        } else { showNotification('â„¹ï¸ åˆ†è§£ã™ã‚‹ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚'); }
      } else {
        showNotification('âŒ ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚APIã‹ã‚‰ã®å¿œç­”ãŒä¸æ­£ã§ã™ã€‚');
        console.error("LLM API Error: Unexpected response structure", result);
      }
    } catch (error) {
      console.error('LLM API Error:', error);
      showNotification('âŒ AIã«ã‚ˆã‚‹ã‚µãƒ–ã‚¿ã‚¹ã‚¯ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
    } finally {
      setIsGeneratingSubtasks(false);
    }
  };

  // LLMã‚’ä½¿ã£ã¦ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
  const generateIdeasWithAI = async () => {
    let ideaTopic = '';
    let parentTaskIdForIdeas = null;
    let contextPath = '';

    if (selectedTaskId) {
      const selectedTask = getAllTasksFlat().find(task => task.id === selectedTaskId);
      if (selectedTask) {
        ideaTopic = selectedTask.title;
        parentTaskIdForIdeas = selectedTask.id;
        contextPath = getTaskPath(selectedTaskId);
      }
    } else if (tasks.length > 0) {
      const userInput = window.prompt("ã©ã‚“ãªãƒ†ãƒ¼ãƒžã§ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’å‡ºã—ã¾ã™ã‹ï¼Ÿ (ä¾‹: æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¢ã‚¤ãƒ‡ã‚¢)");
      if (!userInput) { showNotification('âš ï¸ ãƒ†ãƒ¼ãƒžãŒå…¥åŠ›ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚'); return; }
      ideaTopic = userInput;
      const newParentTask = addTask('root', ideaTopic, colors[0], null, false);
      if (newParentTask) {
        parentTaskIdForIdeas = newParentTask.id;
        setSelectedTaskId(newParentTask.id);
        setExpandedTasks(prev => new Set([...prev, newParentTask.id]));
        contextPath = newParentTask.title;
      } else { showNotification('âŒ è¦ªã‚¿ã‚¹ã‚¯ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); return; }
    } else {
      const userInput = window.prompt("æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã«ã¤ã„ã¦ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’å‡ºã—ã¾ã™ã‹ï¼Ÿ (ä¾‹: å¤ä¼‘ã¿ã®è¨ˆç”»)");
      if (!userInput) { showNotification('âš ï¸ ã‚¿ã‚¹ã‚¯ãŒå…¥åŠ›ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚'); return; }
      ideaTopic = userInput;
      const newTask = addTask('root', ideaTopic, colors[0], null, false);
      if (newTask) {
        parentTaskIdForIdeas = newTask.id;
        setSelectedTaskId(newTask.id);
        setExpandedTasks(prev => new Set([...prev, newTask.id]));
        contextPath = newTask.title;
      } else { showNotification('âŒ ã‚¿ã‚¹ã‚¯ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); return; }
    }

    if (!ideaTopic) { showNotification('âš ï¸ ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’ç”Ÿæˆã™ã‚‹ãƒ†ãƒ¼ãƒžãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); return; }
    if (!parentTaskIdForIdeas) { showNotification('âš ï¸ ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’è¿½åŠ ã™ã‚‹è¦ªã‚¿ã‚¹ã‚¯ãŒç‰¹å®šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚'); return; }

    setIsGeneratingIdeas(true);
    showNotification('âœ¨ ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’ç”Ÿæˆä¸­...');
    try {
      const promptText = `Given the task hierarchy: "${contextPath}", ã€Œ${ideaTopic}ã€ã«ã¤ã„ã¦ã€å…·ä½“çš„ã§å®Ÿè¡Œå¯èƒ½ãªã‚¢ã‚¤ãƒ‡ã‚¢ã‚’2ã¤æ—¥æœ¬èªžã§ç”Ÿæˆã—ã¦ã€‚å›žç­”ã¯JSONå½¢å¼ã®æ–‡å­—åˆ—é…åˆ—ã§ã€å„æ–‡å­—åˆ—ãŒã‚¢ã‚¤ãƒ‡ã‚¢/ã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒˆãƒ«ã«ãªã‚‹ã‚ˆã†ã«ã—ã¦ã­ã€‚å„ã‚¢ã‚¤ãƒ‡ã‚¢ã¯ç°¡æ½”ã§ç›´æŽ¥è¡Œå‹•ã«ç§»ã›ã‚‹ã‚‚ã®ã«ã—ã¦ã­ã€‚`;
      let chatHistory = [{ role: "user", parts: [{ text: promptText }] }];
      const payload = {
        contents: chatHistory,
        generationConfig: { responseMimeType: "application/json", responseSchema: { type: "ARRAY", items: { "type": "STRING" } } }
      };
      const apiKey = "";
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
      const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
      const result = await response.json();

      if (result.candidates && result.candidates[0]?.content?.parts?.[0]?.text) {
        const jsonString = result.candidates[0].content.parts[0].text;
        let ideasFromAI = JSON.parse(jsonString);
        if (ideasFromAI && Array.isArray(ideasFromAI) && ideasFromAI.length > 0) {
          if (ideasFromAI.length > 2) {
            ideasFromAI = ideasFromAI.slice(0, 2);
            showNotification('â„¹ï¸ ç”Ÿæˆã•ã‚ŒãŸã‚¢ã‚¤ãƒ‡ã‚¢ãŒå¤šã™ãŽãŸãŸã‚ã€æœ€åˆã®2ã¤ã«åˆ¶é™ã—ã¾ã—ãŸã€‚');
          }
          const addGeneratedIdeas = (currentTasks, targetParentId) => {
            return currentTasks.map(task => {
              if (task.id === targetParentId) {
                const newIdeas = ideasFromAI.map(ideaTitle => ({
                  id: generateId(), title: ideaTitle, completed: false, color: '#A78BFA',
                  createdAt: new Date(), completedAt: null, subtasks: [], memo: '', emoji: ''
                }));
                newIdeas.forEach(idea => { if (idea.title?.trim()) generateEmojiForTask(idea.id, idea.title); });
                return { ...task, subtasks: [...(task.subtasks || []), ...newIdeas] };
              }
              if (task.subtasks?.length > 0) return { ...task, subtasks: addGeneratedIdeas(task.subtasks, targetParentId) };
              return task;
            });
          };
          setTasks(prev => addGeneratedIdeas(prev, parentTaskIdForIdeas));
          setExpandedTasks(prev => new Set([...prev, parentTaskIdForIdeas]));
          showNotification('âœ… ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’ç”Ÿæˆã—ã¾ã—ãŸï¼');
        } else { showNotification('â„¹ï¸ ã‚¢ã‚¤ãƒ‡ã‚¢ã¯ç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚'); }
      } else { showNotification('âŒ ã‚¢ã‚¤ãƒ‡ã‚¢ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); }
    } catch (error) {
      console.error('LLM API Error:', error);
      showNotification('âŒ AIã«ã‚ˆã‚‹ã‚¢ã‚¤ãƒ‡ã‚¢ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
    } finally {
      setIsGeneratingIdeas(false);
    }
  };

  // LLMã‚’ä½¿ã£ã¦å•ã„ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
  const generateQuestionsWithAI = async () => {
    let questionTopic = '';
    let parentTaskIdForQuestions = null;
    let contextPath = '';

    if (selectedTaskId) {
      const selectedTask = getAllTasksFlat().find(task => task.id === selectedTaskId);
      if (selectedTask) {
        questionTopic = selectedTask.title;
        parentTaskIdForQuestions = selectedTask.id;
        contextPath = getTaskPath(selectedTaskId);
      }
    } else if (tasks.length > 0) {
      const userInput = window.prompt("ã©ã®ã‚¿ã‚¹ã‚¯ã«ã¤ã„ã¦å•ã„ã‚’ç”Ÿæˆã—ã¾ã™ã‹ï¼Ÿ (ä¾‹: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆX)");
      if (!userInput) { showNotification('âš ï¸ ã‚¿ã‚¹ã‚¯ãŒå…¥åŠ›ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚'); return; }
      questionTopic = userInput;
      const newParentTask = addTask('root', questionTopic, colors[0], null, false);
      if (newParentTask) {
        parentTaskIdForQuestions = newParentTask.id;
        setSelectedTaskId(newParentTask.id);
        setExpandedTasks(prev => new Set([...prev, newParentTask.id]));
        contextPath = newParentTask.title;
      } else { showNotification('âŒ è¦ªã‚¿ã‚¹ã‚¯ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); return; }
    } else {
      const userInput = window.prompt("æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã«ã¤ã„ã¦å•ã„ã‚’ç”Ÿæˆã—ã¾ã™ã‹ï¼Ÿ (ä¾‹: æ–°è¦äº‹æ¥­ã®ç«‹ã¡ä¸Šã’)");
      if (!userInput) { showNotification('âš ï¸ ã‚¿ã‚¹ã‚¯ãŒå…¥åŠ›ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚'); return; }
      questionTopic = userInput;
      const newTask = addTask('root', questionTopic, colors[0], null, false);
      if (newTask) {
        parentTaskIdForQuestions = newTask.id;
        setSelectedTaskId(newTask.id);
        setExpandedTasks(prev => new Set([...prev, newTask.id]));
        contextPath = newTask.title;
      } else { showNotification('âŒ ã‚¿ã‚¹ã‚¯ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); return; }
    }

    if (!questionTopic) { showNotification('âš ï¸ å•ã„ã‚’ç”Ÿæˆã™ã‚‹ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); return; }
    if (!parentTaskIdForQuestions) { showNotification('âš ï¸ å•ã„ã‚’è¿½åŠ ã™ã‚‹è¦ªã‚¿ã‚¹ã‚¯ãŒç‰¹å®šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚'); return; }

    setIsGeneratingQuestions(true);
    showNotification('âœ¨ å•ã„ã‚’ç”Ÿæˆä¸­...');
    try {
      const promptText = `Given the task hierarchy: "${contextPath}", ã€Œ${questionTopic}ã€ã¨ã„ã†ã‚¿ã‚¹ã‚¯ã‚’ã‚ˆã‚Šå…·ä½“çš„ã«ã™ã‚‹ãŸã‚ã«ã€ç›®çš„ã€äºˆç®—ã€æœŸé™ã¨ã„ã£ãŸå´é¢ã‹ã‚‰ã€å‹ã ã¡ã®ã‚ˆã†ãªå£èª¿ã§ã€æ´žå¯Ÿã«æº€ã¡ãŸå…·ä½“çš„ãªè³ªå•ã‚’3ã¤æ—¥æœ¬èªžã§ææ¡ˆã—ã¦ã­ã€‚å›žç­”ã¯JSONå½¢å¼ã®æ–‡å­—åˆ—é…åˆ—ã§ã€å„æ–‡å­—åˆ—ãŒè³ªå•ã«ãªã‚‹ã‚ˆã†ã«ã—ã¦ã­ã€‚`;
      let chatHistory = [{ role: "user", parts: [{ text: promptText }] }];
      const payload = {
        contents: chatHistory,
        generationConfig: { responseMimeType: "application/json", responseSchema: { type: "ARRAY", items: { "type": "STRING" } } }
      };
      const apiKey = "";
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
      const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
      const result = await response.json();

      if (result.candidates && result.candidates[0]?.content?.parts?.[0]?.text) {
        const jsonString = result.candidates[0].content.parts[0].text;
        const questionsFromAI = JSON.parse(jsonString);
        if (questionsFromAI && Array.isArray(questionsFromAI) && questionsFromAI.length > 0) {
          const addGeneratedQuestions = (currentTasks, targetParentId) => {
            return currentTasks.map(task => {
              if (task.id === targetParentId) {
                const newQuestions = questionsFromAI.map(questionTitle => ({
                  id: generateId(), title: questionTitle, completed: false, color: '#1F2937',
                  createdAt: new Date(), completedAt: null, subtasks: [], memo: '', emoji: ''
                }));
                newQuestions.forEach(q => { if (q.title?.trim()) generateEmojiForTask(q.id, q.title); });
                return { ...task, subtasks: [...(task.subtasks || []), ...newQuestions] };
              }
              if (task.subtasks?.length > 0) return { ...task, subtasks: addGeneratedQuestions(task.subtasks, targetParentId) };
              return task;
            });
          };
          setTasks(prev => addGeneratedQuestions(prev, parentTaskIdForQuestions));
          setExpandedTasks(prev => new Set([...prev, parentTaskIdForQuestions]));
          showNotification('âœ… å•ã„ã‚’ã‚¿ã‚¹ã‚¯ã¨ã—ã¦è¿½åŠ ã—ã¾ã—ãŸï¼');
        } else { showNotification('â„¹ï¸ å•ã„ã¯ç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚'); }
      } else { showNotification('âŒ å•ã„ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); }
    } catch (error) {
      console.error('LLM API Error:', error);
      showNotification('âŒ AIã«ã‚ˆã‚‹å•ã„ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
    } finally {
      setIsGeneratingQuestions(false);
    }
  };


  // ã‚¿ã‚¹ã‚¯ã‚«ãƒ¼ãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
  const TaskCard = ({ task, level = 0 }) => {
    const isExpanded = expandedTasks.has(task.id);
    const hasSubtasks = task.subtasks && task.subtasks.length > 0;
    const isIdeaTask = task.color === '#A78BFA';
    const isGeneratedSubtask = task.color === '#22C55E';
    const isQuestionTask = task.color === '#1F2937';

    return (
      <div className="mb-2">
        <div
          className={`rounded-lg border-2 transition-all duration-200 cursor-pointer hover:scale-[1.01] group ${
            task.completed ? 'opacity-60 ' : ''
          } ${
            selectedTaskId === task.id
              ? 'ring-4 ring-blue-400 ring-offset-2 shadow-lg border-blue-400 '
              : 'border-gray-200 hover:border-gray-300 hover:shadow-md '
          } ${
            isIdeaTask ? 'bg-gradient-to-r from-purple-300 to-purple-500 text-white' : ''
          } ${
            isQuestionTask ? 'bg-gradient-to-r from-gray-700 to-gray-900 text-white' : ''
          }`}
          style={{
            marginLeft: `${level * 24}px`,
            backgroundColor: (isIdeaTask || isQuestionTask) ? undefined : getTaskBackgroundColor(task.color, level),
            borderLeftColor: level > 0 ? getTaskBorderColor(task.color, level) : undefined,
            borderLeftWidth: level > 0 ? '4px' : undefined
          }}
          data-task-id={task.id}
          onClick={() => {
            setSelectedTaskId(selectedTaskId === task.id ? null : task.id);
            setIsEmptyAreaSelected(false);
          }}
        >
          <div className="p-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-3 flex-1">
                <div className="flex items-center space-x-2">
                  {hasSubtasks && (
                    <button
                      onClick={(e) => { e.stopPropagation(); toggleExpanded(task.id); }}
                      className="text-gray-400 hover:text-gray-600 transition-colors p-1 rounded hover:bg-gray-100"
                    >
                      {isExpanded ? <ChevronDown size={18} className="text-blue-600" /> : <ChevronRight size={18} />}
                    </button>
                  )}
                  <button
                    onClick={(e) => { e.stopPropagation(); toggleComplete(task.id); }}
                    className={`w-6 h-6 rounded-full border-2 flex items-center justify-center transition-all duration-200 hover:scale-110 ${
                      task.completed ? 'bg-green-500 border-green-500 text-white shadow-md' : 'border-gray-300 hover:border-green-400 hover:bg-green-50'
                    }`}
                  >
                    {task.completed && <Check size={14} />}
                  </button>
                </div>
                <div className="flex items-center space-x-3 flex-1">
                  <div className="relative">
                    <button
                      onClick={(e) => { e.stopPropagation(); setShowColorPicker(showColorPicker === task.id ? null : task.id); }}
                      className="w-5 h-5 rounded-full border-2 border-white shadow-md hover:scale-125 transition-transform duration-200"
                      style={{ backgroundColor: task.color }}
                      title="è‰²ã‚’å¤‰æ›´"
                    />
                    {showColorPicker === task.id && (
                      <>
                        <div className="fixed inset-0 z-[9998] bg-black bg-opacity-30" onClick={() => setShowColorPicker(null)}></div>
                        <div className="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-[9999] bg-white rounded-xl shadow-2xl border-2 p-4 max-w-sm">
                          <div className="flex items-center justify-between mb-3">
                            <h3 className="text-base font-bold text-gray-800">è‰²ã‚’é¸æŠž</h3>
                            <button onClick={() => setShowColorPicker(null)} className="text-gray-400 hover:text-gray-600 text-lg font-bold w-6 h-6 flex items-center justify-center hover:bg-gray-100 rounded-full transition-all">Ã—</button>
                          </div>
                          <div className="flex space-x-3">
                            {colors.map((color, index) => (
                              <div key={color} className="relative">
                                <button
                                  onClick={() => changeTaskColor(task.id, color)}
                                  className={`w-10 h-10 rounded-full border-2 hover:scale-110 transition-all duration-200 shadow-md hover:shadow-lg ${
                                    task.color === color ? 'border-gray-800 ring-3 ring-gray-300 scale-105' :
                                    selectedColorIndex === index ? 'border-blue-500 ring-2 ring-blue-300 scale-105' :
                                    'border-white hover:border-gray-300'
                                  }`}
                                  style={{ backgroundColor: color }}
                                  title={color === '#3B82F6' ? 'é’ï¼šæ¨™æº–ã‚¿ã‚¹ã‚¯' : color === '#EF4444' ? 'èµ¤ï¼šé‡è¦ãƒ»ç·Šæ€¥' : color === '#FBBF24' ? 'é»„ï¼šç·Šæ€¥ãƒ»ä¿ç•™' : color === '#22C55E' ? 'ç·‘ï¼šAIåˆ†è§£ã‚¿ã‚¹ã‚¯' : color === '#A78BFA' ? 'ç´«ï¼šAIã‚¢ã‚¤ãƒ‡ã‚¢' : 'é»’ï¼šAIå•ã„ç”Ÿæˆ'}
                                />
                                {selectedColorIndex === index && (
                                  <div className="absolute -top-1 -right-1 w-3 h-3 bg-blue-500 rounded-full flex items-center justify-center">
                                    <div className="w-1.5 h-1.5 bg-white rounded-full"></div>
                                  </div>
                                )}
                              </div>
                            ))}
                          </div>
                          <div className="text-xs text-gray-500 mt-2 text-center">â† â†’ ã§é¸æŠžã€Enter ã§æ±ºå®š</div>
                        </div>
                      </>
                    )}
                  </div>
                  {editingTask === task.id ? (
                    <input
                      ref={(el) => { if (el) editInputRefs.current[task.id] = el; }}
                      type="text"
                      className="flex-1 font-medium text-gray-800 bg-white border-2 border-blue-400 rounded-lg px-3 py-2 focus:ring-4 focus:ring-blue-200 focus:border-blue-500 transition-all"
                      onKeyDown={(e) => {
                        if (e.key === 'Enter') { e.preventDefault(); finishEditTask(task.id); }
                        else if (e.key === 'Escape') { e.preventDefault(); setEditingTask(null); }
                      }}
                      onClick={(e) => e.stopPropagation()}
                    />
                  ) : (
                    <div className="flex items-center space-x-2 flex-1">
                      {task.emoji && <span className="text-xl">{task.emoji}</span>}
                      <span
                        className={`font-medium cursor-pointer hover:text-blue-600 transition-colors select-none ${
                          task.completed ? 'line-through text-gray-500' : isIdeaTask || isQuestionTask ? 'text-white' : 'text-gray-800'
                        } ${isIdeaTask || isQuestionTask ? 'text-sm' : 'text-lg'}`}
                        onDoubleClick={() => startEditTask(task.id)}
                        onClick={(e) => { e.stopPropagation(); startEditTask(task.id); }}
                        title="ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†"
                      >
                        {task.title}
                        <div className="flex items-center space-x-2 mt-1">
                          <span className={`text-xs font-normal ${isIdeaTask || isQuestionTask ? 'text-gray-200' : 'text-gray-400'}`}>
                            ä½œæˆ: {task.createdAt ? formatDateTime(task.createdAt) : ''}
                          </span>
                          {task.completed && task.completedAt && (
                            <>
                              <span className="text-xs text-red-500 font-normal">å®Œäº†: {formatDateTime(task.completedAt)}</span>
                              <span className="text-xs text-blue-600 font-medium bg-blue-50 px-2 py-0.5 rounded-full">
                                æ‰€è¦æ™‚é–“: {calculateTimeDifference(task.createdAt, task.completedAt)}
                              </span>
                            </>
                          )}
                        </div>
                      </span>
                    </div>
                  )}
                </div>
              </div>
              <button
                onClick={(e) => { e.stopPropagation(); openMemoModal(task); }}
                className={`p-2 rounded-lg transition-all duration-200 ${
                  task.memo
                    ? 'text-purple-500 hover:bg-purple-50'
                    : 'text-gray-400 opacity-0 group-hover:opacity-100 hover:bg-gray-100'
                }`}
                title={task.memo ? 'ãƒ¡ãƒ¢ã‚ã‚Š' : 'è©³ç´°ãƒ¡ãƒ¢ã‚’è¿½åŠ '}
              >
                <FileText size={18} />
              </button>
              <div className="flex items-center space-x-1 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                <button
                  onClick={(e) => { e.stopPropagation(); setShowAddForm(task.id); }}
                  className="text-gray-400 hover:text-blue-500 p-2 rounded-lg hover:bg-blue-50 transition-all duration-200"
                  title="ã‚µãƒ–ã‚¿ã‚¹ã‚¯è¿½åŠ "
                >
                  <Plus size={18} />
                </button>
                <button
                  onClick={(e) => { e.stopPropagation(); deleteTask(task.id); }}
                  className="text-gray-400 hover:text-red-500 p-2 rounded-lg hover:bg-red-50 transition-all duration-200"
                  title="å‰Šé™¤"
                >
                  <X size={18} />
                </button>
              </div>
            </div>
          </div>
        </div>
        {hasSubtasks && isExpanded && (
          <div className="mt-2 space-y-2">
            {task.subtasks.map(subtask => (
              <TaskCard key={subtask.id} task={subtask} level={level + 1} />
            ))}
          </div>
        )}
        {showAddForm === task.id && (
          <div
            className="border-2 rounded-xl p-4 mt-3 shadow-md"
            style={{
              marginLeft: `${(level + 1) * 24}px`,
              backgroundColor: getTaskBackgroundColor(task.color, level + 1),
              borderColor: getTaskBorderColor(task.color, level + 1)
            }}
          >
            <div className="flex items-center space-x-3">
              <input
                ref={(el) => { if (el) subtaskInputRefs.current[task.id] = el; }}
                type="text"
                placeholder="ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆEnterã§è¿½åŠ ï¼‰"
                onKeyDown={(e) => { if (e.key === 'Enter') { e.preventDefault(); addTask(task.id, '', null, null, false); } }}
                className="flex-1 px-4 py-3 border-2 border-blue-300 rounded-lg focus:ring-4 focus:ring-blue-200 focus:border-blue-500 text-base transition-all"
                autoFocus
              />
              <button onClick={() => addTask(task.id, '', null, null, false)} className="px-4 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium transition-all duration-200 hover:scale-105 shadow-md">è¿½åŠ </button>
              <button onClick={() => setShowAddForm(null)} className="px-3 py-3 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-lg transition-all">âœ•</button>
            </div>
          </div>
        )}
      </div>
    );
  };

  const currentStats = calculateStats();

  return (
    <div className={`min-h-screen transition-all duration-500 ${isFocusMode ? 'bg-gradient-to-br from-red-300 via-red-500 to-red-700' : 'bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50'}`}>
      {notification && (
        <div className="fixed top-4 right-4 bg-gradient-to-r from-green-500 to-emerald-500 text-white px-6 py-3 rounded-xl shadow-xl z-50">
          <div className="flex items-center space-x-2">
            <div className="w-2 h-2 bg-white rounded-full animate-pulse"></div>
            <span className="font-medium">{notification}</span>
            {lastDeletedTaskInfo && (
              <button
                onClick={(e) => { e.stopPropagation(); undoDelete(); }}
                className="ml-4 px-3 py-1 bg-white text-green-600 rounded-lg font-semibold hover:bg-green-100 transition-colors"
              >
                å…ƒã«æˆ»ã™
              </button>
            )}
            <button onClick={() => {
              setNotification('');
              if (undoNotificationTimerRef.current) {
                clearTimeout(undoNotificationTimerRef.current);
                undoNotificationTimerRef.current = null;
              }
              setLastDeletedTaskInfo(null);
            }} className="ml-2 text-white hover:text-gray-200 text-lg font-bold w-6 h-6 flex items-center justify-center rounded-full transition-all" title="é–‰ã˜ã‚‹">âœ•</button>
          </div>
        </div>
      )}
      <header className="bg-white/80 backdrop-blur-md shadow-lg border-b border-gray-200 sticky top-0 z-10">
        <div className="max-w-7xl mx-auto px-6 py-5">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-4">
              <div className="p-2 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-xl"><Target className="text-white" size={28} /></div>
              <div><h1 className="text-3xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 bg-clip-text text-transparent">TODO Manager</h1></div>
            </div>
            <div className="flex items-center space-x-3">
              <button
                onClick={() => {
                  const newTask = addTask('root', '', newTaskColor, null, true); // isFromShortcut = true
                  if (newTask) startEditTask(newTask.id);
                }}
                className="flex items-center space-x-3 px-4 py-2 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white rounded-xl font-medium transition-all duration-200 hover:scale-105 transform shadow-md text-sm"
              >
                <Plus size={18} /><span>æ–°ã—ã„ã‚¿ã‚¹ã‚¯</span>
              </button>
              <button onClick={generateSubtasksWithAI} className={`flex items-center space-x-3 px-4 py-2 bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-xl font-medium transition-all duration-200 hover:scale-105 transform shadow-md text-sm ${isGeneratingSubtasks ? 'opacity-60 cursor-not-allowed' : ''}`} disabled={isGeneratingSubtasks} title="AIãŒã‚¿ã‚¹ã‚¯ã‚’ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã«åˆ†è§£ã—ã¾ã™">
                <Lightbulb size={18} /><span>{isGeneratingSubtasks ? 'ç”Ÿæˆä¸­...' : 'åˆ†è§£'}</span>
              </button>
              <button onClick={generateIdeasWithAI} className={`flex items-center space-x-3 px-4 py-2 bg-gradient-to-r from-purple-500 to-indigo-600 text-white rounded-xl font-medium transition-all duration-200 hover:scale-105 transform shadow-md text-sm ${isGeneratingIdeas ? 'opacity-60 cursor-not-allowed' : ''}`} disabled={isGeneratingIdeas} title="AIãŒæ–°ã—ã„ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’ç”Ÿæˆã—ã¾ã™">
                <Lightbulb size={18} /><span>{isGeneratingIdeas ? 'ç”Ÿæˆä¸­...' : 'ã‚¢ã‚¤ãƒ‡ã‚¢å‡ºã—'}</span>
              </button>
              <button onClick={generateQuestionsWithAI} className={`flex items-center space-x-3 px-4 py-2 bg-gradient-to-r from-gray-800 to-black text-white rounded-xl font-medium transition-all duration-200 hover:scale-105 transform shadow-md text-sm ${isGeneratingQuestions ? 'opacity-60 cursor-not-allowed' : ''}`} disabled={isGeneratingQuestions} title="AIãŒã‚¿ã‚¹ã‚¯ã‚’ç£¨ããŸã‚ã®å•ã„ã‚’ç”Ÿæˆã—ã¾ã™">
                <HelpCircle size={18} /><span>{isGeneratingQuestions ? 'ç”Ÿæˆä¸­...' : 'å•ã„ç”Ÿæˆ'}</span>
              </button>
              <button onClick={() => { if (selectedTaskId) moveTaskToTop(selectedTaskId); else showNotification('âš ï¸ ã¾ãšã‚¿ã‚¹ã‚¯ã‚’é¸ã‚“ã§ã­ï¼'); }} className={`flex items-center space-x-3 px-4 py-2 text-sm text-white bg-gradient-to-r from-blue-400 to-cyan-500 rounded-xl font-medium transition-all duration-200 hover:scale-105 transform shadow-md ${!selectedTaskId ? 'opacity-60 cursor-not-allowed' : ''}`} disabled={!selectedTaskId} title="é¸æŠžã—ãŸã‚¿ã‚¹ã‚¯ã‚’ä¸€ç•ªä¸Šã«ç§»å‹• (Ctrl+U)">
                <ArrowUp size={18} /><span>ä¸€ç•ªä¸Šã«</span>
              </button>
              <button onClick={() => { if (!selectedTaskId && !isFocusMode) { showNotification('âš ï¸ é›†ä¸­ãƒ¢ãƒ¼ãƒ‰ã«ã™ã‚‹ã«ã¯ã€ã¾ãšã‚¿ã‚¹ã‚¯ã‚’é¸ã‚“ã§ã­ï¼'); return; } setIsFocusMode(prev => !prev); showNotification(!isFocusMode ? 'ðŸŽ¯ é›†ä¸­ãƒ¢ãƒ¼ãƒ‰ã«ãªã£ãŸã‚ˆï¼' : 'ðŸ‘€ ã‚¿ã‚¹ã‚¯ç¢ºèªãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã£ãŸã‚ˆï¼'); }} className={`flex items-center space-x-2 px-4 py-2 text-sm rounded-xl font-medium transition-all duration-200 hover:scale-105 transform shadow-md ${isFocusMode ? 'bg-gradient-to-r from-orange-400 to-yellow-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`} title={isFocusMode ? 'é›†ä¸­ãƒ¢ãƒ¼ãƒ‰ã‚’è§£é™¤' : 'é¸æŠžã—ãŸã‚¿ã‚¹ã‚¯ã«é›†ä¸­'}>
                {isFocusMode ? (<><HelpCircle size={18} /><span>ç¢ºèªãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã‚‹</span></>) : (<><Target size={18} /><span>é›†ä¸­ãƒ¢ãƒ¼ãƒ‰ã«ã™ã‚‹</span></>)}
              </button>
              <button onClick={() => setShowImportArea(!showImportArea)} className="flex items-center space-x-2 px-4 py-2 text-sm text-gray-600 hover:text-blue-600 transition-all rounded-lg hover:bg-blue-50 border border-gray-200 hover:border-blue-300">
                <Upload size={18} /><span>ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</span>
              </button>
              <div className="relative">
                <button ref={exportButtonRef} onClick={() => setShowExportOptions(!showExportOptions)} className="flex items-center space-x-2 px-4 py-2 text-sm text-gray-600 hover:text-blue-600 transition-all rounded-lg hover:bg-blue-50 border border-gray-200 hover:border-blue-300">
                  <Download size={18} /><span>ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</span>
                </button>
              </div>
              <button onClick={() => { setTasks([]); setExpandedTasks(new Set()); setSelectedTaskId(null); setIsEmptyAreaSelected(false); setShowAddForm(null); showNotification('ðŸ§¹ ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¾ã—ãŸ'); localStorage.removeItem('todoAppTasks_v2'); localStorage.removeItem('todoAppExpandedTasks_v2'); }} className="flex items-center space-x-2 px-4 py-2 text-sm text-white bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 rounded-lg transition-all duration-200 hover:scale-105 transform shadow-md">
                <Trash2 size={18} /><span>å…¨å‰Šé™¤</span>
              </button>
            </div>
          </div>
        </div>
      </header>
      <div className="max-w-7xl mx-auto px-6 py-8 flex gap-8">
        <div className="flex-1">
          {showImportArea && (
            <div className="bg-gradient-to-r from-blue-50 to-indigo-50 border-2 border-blue-200 rounded-xl p-6 mb-8 shadow-md">
              <h3 className="font-bold text-blue-800 mb-3 text-lg">ðŸ“¥ ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</h3>
              <div className="space-y-4">
                <div className="text-sm text-blue-700 bg-blue-100 rounded-lg p-3">
                  <div className="font-medium mb-2">ðŸ’¡ å¯¾å¿œå½¢å¼:</div>
                  <div className="space-y-1 text-xs">
                    <div><strong>JSONå½¢å¼:</strong> ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ãŸJSONãƒ‡ãƒ¼ã‚¿</div>
                    <div><strong>ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼:</strong> 1è¡Œ1ã‚¿ã‚¹ã‚¯ã€å­ã‚¿ã‚¹ã‚¯ã¯ã€Œã€€â””ã€ã§é–‹å§‹ (ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã§éšŽå±¤åŒ–)</div>
                  </div>
                </div>
                <div className="flex items-center space-x-4">
                  <span className="text-sm font-medium text-gray-700">ãƒ¢ãƒ¼ãƒ‰:</span>
                  <label className="inline-flex items-center"><input type="radio" className="form-radio text-blue-600" name="importMode" value="add" checked={importMode === 'add'} onChange={() => setImportMode('add')} /><span className="ml-2 text-gray-700">è¿½åŠ </span></label>
                  <label className="inline-flex items-center"><input type="radio" className="form-radio text-blue-600" name="importMode" value="overwrite" checked={importMode === 'overwrite'} onChange={() => setImportMode('overwrite')} /><span className="ml-2 text-gray-700">ä¸Šæ›¸ã</span></label>
                </div>
                <textarea placeholder="JSONãƒ‡ãƒ¼ã‚¿ã¾ãŸã¯ãƒ†ã‚­ã‚¹ãƒˆã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„..." className="w-full px-4 py-3 border-2 border-blue-300 rounded-lg resize-none focus:ring-4 focus:ring-blue-200 focus:border-blue-500 text-base transition-all" rows="6" id="import-textarea"></textarea>
                <button onClick={() => { const textareaElement = document.getElementById('import-textarea'); if (textareaElement && textareaElement.value.trim()) { importData(textareaElement.value); textareaElement.value = ''; setShowImportArea(false); } else { showNotification('âš ï¸ ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); } }} className="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium transition-all duration-200 hover:scale-105 shadow-md">ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Ÿè¡Œ</button>
              </div>
            </div>
          )}
          {showExportedData && (
            <div className="bg-gradient-to-r from-green-50 to-emerald-50 border-2 border-green-200 rounded-xl p-6 mb-8 shadow-md">
              <div className="flex items-center justify-between mb-3">
                <h3 className="font-bold text-green-800 text-lg">ðŸ“¤ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ãŸãƒ‡ãƒ¼ã‚¿</h3>
                <button onClick={() => setShowExportedData(false)} className="text-green-600 hover:text-green-800 hover:bg-green-100 rounded-lg p-2 transition-all" title="é–‰ã˜ã‚‹">âœ•</button>
              </div>
              <div className="bg-white border border-green-300 rounded-lg p-4 max-h-96 overflow-y-auto"><pre className="text-sm text-gray-800 whitespace-pre-wrap font-mono">{exportedData}</pre></div>
              <div className="mt-3 flex items-center space-x-2 text-sm text-green-700"><span>ðŸ“‹ ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚‚ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã—ãŸ</span></div>
            </div>
          )}
          {showAddForm === 'root' && (
            <div className="bg-white rounded-xl shadow-lg border-2 border-gray-200 p-6 mb-8">
              <h3 className="text-xl font-bold text-gray-800 mb-4 flex items-center"><Plus className="mr-2 text-blue-600" size={20} />æ–°ã—ã„ã‚¿ã‚¹ã‚¯</h3>
              <div className="space-y-4">
                <div className="flex items-center space-x-3">
                  <span className="text-sm font-medium text-gray-700">è‰²:</span>
                  <div className="relative">
                    <button onClick={() => setShowNewTaskColorPicker(!showNewTaskColorPicker)} className="w-8 h-8 rounded-full border-2 border-white shadow-md hover:scale-110 transition-transform duration-200" style={{ backgroundColor: newTaskColor }} title="è‰²ã‚’é¸æŠž" />
                    {showNewTaskColorPicker && (
                      <>
                        <div className="fixed inset-0 z-[9998] bg-black bg-opacity-30" onClick={() => setShowNewTaskColorPicker(false)}></div>
                        <div className="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-[9999] bg-white rounded-xl shadow-2xl border-2 p-4 max-w-sm">
                          <div className="flex items-center justify-between mb-3"><h3 className="text-base font-bold text-gray-800">è‰²ã‚’é¸æŠž</h3><button onClick={() => setShowNewTaskColorPicker(false)} className="text-gray-400 hover:text-gray-600 text-lg font-bold w-6 h-6 flex items-center justify-center hover:bg-gray-100 rounded-full transition-all">Ã—</button></div>
                          <div className="flex space-x-3">
                            {colors.map(color => (<button key={color} onClick={() => { setNewTaskColor(color); setShowNewTaskColorPicker(false); }} className={`w-10 h-10 rounded-full border-2 hover:scale-110 transition-all duration-200 shadow-md hover:shadow-lg ${newTaskColor === color ? 'border-gray-800 ring-3 ring-gray-300 scale-105' : 'border-white hover:border-gray-300'}`} style={{ backgroundColor: color }} title={color === '#3B82F6' ? 'é’ï¼šæ¨™æº–ã‚¿ã‚¹ã‚¯' : color === '#EF4444' ? 'èµ¤ï¼šé‡è¦ãƒ»ç·Šæ€¥' : color === '#FBBF24' ? 'é»„ï¼šç·Šæ€¥ãƒ»ä¿ç•™' : color === '#22C55E' ? 'ç·‘ï¼šAIåˆ†è§£ã‚¿ã‚¹ã‚¯' : color === '#A78BFA' ? 'ç´«ï¼šAIã‚¢ã‚¤ãƒ‡ã‚¢' : 'é»’ï¼šAIå•ã„ç”Ÿæˆ'} />))}
                          </div>
                        </div>
                      </>
                    )}
                  </div>
                </div>
                <div className="flex items-center space-x-4">
                  <input ref={mainInputRef} type="text" placeholder="ã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆEnterã§è¿½åŠ ï¼‰" onKeyDown={(e) => { if (e.key === 'Enter') { e.preventDefault(); addTask('root', mainInputRef.current?.value || '', newTaskColor, null, false); } }} className="flex-1 px-4 py-3 border-2 border-gray-300 rounded-lg focus:ring-4 focus:ring-blue-200 focus:focus:border-blue-500 text-base transition-all" autoFocus />
                  <button onClick={() => addTask('root', mainInputRef.current?.value || '', newTaskColor, null, false)} className="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium transition-all duration-200 hover:scale-105 shadow-md">è¿½åŠ </button>
                  <button onClick={() => { setShowAddForm(null); setShowNewTaskColorPicker(false); }} className="px-4 py-3 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-lg transition-all">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                </div>
              </div>
            </div>
          )}
          <div className="space-y-3">
            {tasks.length === 0 ? (
              <div className="text-center py-16">
                <div className="p-4 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-full w-20 h-20 mx-auto mb-6 flex items-center justify-center"><Target size={40} className="text-white" /></div>
                <h3 className="text-xl font-semibold text-gray-700 mb-2">ã¾ã ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“</h3>
                <p className="text-gray-500">ä¸Šã®ãƒœã‚¿ãƒ³ã‹ã‚‰æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ã¦ãã ã•ã„</p>
              </div>
            ) : (
              <>
                {getFilteredTasksForFocusMode().map(task => (<TaskCard key={task.id} task={task} />))}
                <div data-empty-area="true" className={`h-12 rounded-xl border-2 border-dashed transition-all cursor-pointer hover:scale-[1.01] ${isEmptyAreaSelected ? 'border-blue-500 bg-blue-50 shadow-md' : 'border-gray-300 hover:border-gray-400 hover:bg-gray-50'}`} onClick={() => { setIsEmptyAreaSelected(!isEmptyAreaSelected); setSelectedTaskId(null); }} title="ç©ºã®ã‚¨ãƒªã‚¢ï¼ˆé¸æŠžã—ã¦Enterã§æ–°è¦ã‚¿ã‚¹ã‚¯è¿½åŠ ï¼‰">
                  <div className="flex items-center justify-center h-full">{isEmptyAreaSelected ? (<div className="text-sm text-blue-600 font-medium">âœ¨ Enterã§æ–°è¦ã‚¿ã‚¹ã‚¯è¿½åŠ </div>) : (<div className="text-sm text-gray-400">ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠž</div>)}</div>
                </div>
              </>
            )}
          </div>
        </div>
        <div className="w-80 space-y-6">
          <div className="bg-white/80 backdrop-blur-md rounded-xl shadow-lg border border-gray-200 p-6">
            <h3 className="text-lg font-bold text-gray-800 mb-4 flex items-center"><BarChart3 className="mr-2 text-blue-600" size={20} />é€²æ—çŠ¶æ³</h3>
            <div className="space-y-4">
              <div className="flex items-center justify-between text-sm"><span className="text-gray-600">å®Œäº†æ¸ˆã¿</span><span className="font-bold text-green-600">{currentStats.completed}</span></div>
              <div className="flex items-center justify-between text-sm"><span className="text-gray-600">é€²è¡Œä¸­</span><span className="font-bold text-blue-600">{currentStats.inProgress}</span></div>
              <div className="flex items-center justify-between text-sm"><span className="text-gray-600">åˆè¨ˆ</span><span className="font-bold text-gray-800">{currentStats.total}</span></div>
              <div className="mt-4">
                <div className="w-full bg-gray-200 rounded-full h-3 overflow-hidden"><div className="h-full bg-gradient-to-r from-blue-500 to-indigo-600 rounded-full transition-all duration-500 ease-out" style={{ width: `${currentStats.progress}%` }}></div></div>
              </div>
               <button
                onClick={handleDeleteCompletedTasks}
                className="mt-4 w-full flex items-center justify-center space-x-2 px-4 py-2 text-sm text-red-600 hover:text-white bg-red-100 hover:bg-red-600 transition-all rounded-lg border border-red-300 hover:border-red-600 shadow-sm"
                title="å®Œäº†æ¸ˆã¿ã®ã‚¿ã‚¹ã‚¯ã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¾ã™"
              >
                <Trash2 size={16} />
                <span>å®Œäº†æ¸ˆã¿ã®ã‚¿ã‚¹ã‚¯å‰Šé™¤</span>
              </button>
            </div>
          </div>
          <div className="bg-white/80 backdrop-blur-md rounded-xl shadow-lg border border-gray-200 p-6">
            <h3 className="text-lg font-bold text-gray-800 mb-4">âŒ¨ï¸ ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ</h3>
            <div className="space-y-3 text-sm">
              <div className="flex justify-between"><span className="text-gray-600">â†‘ â†“</span><span className="text-gray-800">ã‚¿ã‚¹ã‚¯é¸æŠž</span></div>
              <div className="flex justify-between"><span className="text-gray-600">Enter</span><span className="text-gray-800">ã‚µãƒ–ã‚¿ã‚¹ã‚¯è¿½åŠ </span></div>
              <div className="flex justify-between"><span className="text-gray-600">Ctrl+Enter</span><span className="text-gray-800">å®Œäº†åˆ‡æ›¿</span></div>
              <div className="flex justify-between"><span className="text-gray-600">Ctrl+Shift+Enter</span><span className="text-gray-800">åŒéšŽå±¤ã‚¿ã‚¹ã‚¯è¿½åŠ </span></div>
              <div className="flex justify-between"><span className="text-gray-600">Space</span><span className="text-gray-800">ç·¨é›†é–‹å§‹</span></div>
              <div className="flex justify-between"><span className="text-gray-600">Tab</span><span className="text-gray-800">éšŽå±¤ä¸‹ã’</span></div>
              <div className="flex justify-between"><span className="text-gray-600">Shift+Tab</span><span className="text-gray-800">éšŽå±¤ä¸Šã’</span></div>
              <div className="flex justify-between"><span className="text-gray-600">Shift+Alt+â†‘â†“</span><span className="text-gray-800">é †åºå¤‰æ›´ (å¾ªç’°)</span></div>
              <div className="flex justify-between"><span className="text-gray-600">Ctrl+C</span><span className="text-gray-800">è‰²é¸æŠž</span></div>
              <div className="flex justify-between"><span className="text-gray-600">Delete</span><span className="text-gray-800">å‰Šé™¤</span></div>
              <div className="flex justify-between"><span className="text-gray-600">Esc</span><span className="text-gray-800">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</span></div>
              <div className="flex justify-between"><span className="text-gray-600">F2</span><span className="text-gray-800">ãƒ¡ãƒ¢ã‚’é–‹ã</span></div>
              <div className="flex justify-between"><span className="text-gray-600">Ctrl+U</span><span className="text-gray-800">ä¸€ç•ªä¸Šã«ç§»å‹•</span></div>
              <div className="flex justify-between"><span className="text-gray-600">Ctrl+D</span><span className="text-gray-800">ä¸€ç•ªä¸‹ã«ç§»å‹•</span></div> {/* Added Ctrl+D shortcut */}
              <div className="flex justify-between"><span className="text-gray-600">Ctrl+I</span><span className="text-gray-800">é›†ä¸­ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿</span></div>
              <div className="flex justify-between"><span className="text-gray-600">Shift+Enter</span><span className="text-gray-800">è¦ªã‚¿ã‚¹ã‚¯è¿½åŠ  (å³æ™‚ç·¨é›†)</span></div>
              <div className="flex justify-between"><span className="text-gray-600">Enter (ã‚¿ã‚¹ã‚¯ãªã—æ™‚)</span><span className="text-gray-800">è¦ªã‚¿ã‚¹ã‚¯è¿½åŠ  (å³æ™‚ç·¨é›†)</span></div>
              <div className="flex justify-between"><span className="text-gray-600">ãƒ¡ãƒ¢ç·¨é›†æ™‚ Ctrl+Enter</span><span className="text-gray-800">ä¿å­˜</span></div>
            </div>
          </div>
          <div className="bg-white/80 backdrop-blur-md rounded-xl shadow-lg border border-gray-200 p-6">
            <h3 className="text-lg font-bold text-gray-800 mb-4">ðŸŽ¨ è‰²åˆ†ã‘ã‚¬ã‚¤ãƒ‰</h3>
            <div className="space-y-3">
              {colors.map((color) => (
                <div key={color} className="flex items-center space-x-3">
                  <div className="w-4 h-4 rounded-full border border-gray-300" style={{ backgroundColor: color }}></div>
                  <span className="text-sm text-gray-700">
                    {color === '#3B82F6' ? 'æ¨™æº–ã‚¿ã‚¹ã‚¯' : color === '#EF4444' ? 'é‡è¦ãƒ»ç·Šæ€¥' : color === '#FBBF24' ? 'æ³¨æ„ãƒ»ä¿ç•™' : color === '#22C55E' ? 'AIåˆ†è§£ã‚¿ã‚¹ã‚¯' : color === '#A78BFA' ? 'AIã‚¢ã‚¤ãƒ‡ã‚¢' : 'AIå•ã„ç”Ÿæˆ'}
                  </span>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
      {showMemoModal && (
        <>
          <div className="fixed inset-0 z-[9998] bg-black bg-opacity-50 flex items-center justify-center p-4" onClick={() => { setShowMemoModal(null); setCurrentMemo(''); }}>
            <div className="bg-white rounded-xl shadow-2xl p-6 w-full max-w-lg relative" onClick={(e) => e.stopPropagation()}>
              <h3 className="text-xl font-bold text-gray-800 mb-4">ðŸ“ ãƒ¡ãƒ¢ã‚’ç·¨é›†</h3>
              <textarea
                className="w-full h-48 p-3 border-2 border-gray-300 rounded-lg focus:ring-4 focus:ring-blue-200 focus:border-blue-500 text-base resize-none"
                value={currentMemo}
                onChange={(e) => setCurrentMemo(e.target.value)}
                onKeyDown={(e) => {
                  if (e.ctrlKey && e.key === 'Enter') {
                    e.preventDefault(); // æ”¹è¡Œã‚’é˜²ã
                    if (showMemoModal) saveMemo(showMemoModal, currentMemo);
                  }
                }}
                placeholder="ã“ã“ã«ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..."
                autoFocus
              />
              <div className="flex justify-end space-x-3 mt-4">
                <button onClick={() => { if (showMemoModal) saveMemo(showMemoModal, currentMemo); }} className="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium transition-all duration-200 hover:scale-105 shadow-md">ä¿å­˜</button>
                <button onClick={() => { setShowMemoModal(null); setCurrentMemo(''); }} className="px-6 py-3 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-lg transition-all">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
              </div>
            </div>
          </div>
        </>
      )}
      {showExportOptions && (
        <>
          <div className="fixed inset-0 z-[9998] bg-black bg-opacity-30" onClick={() => setShowExportOptions(false)}></div>
          <div className="fixed z-[9999] bg-white rounded-xl shadow-xl border-2 p-3 min-w-48" style={{ top: exportDropdownPosition.top, left: exportDropdownPosition.left, transform: 'translateX(-100%)' }}>
            <h3 className="text-sm font-bold text-gray-800 mb-2">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå½¢å¼</h3>
            <div className="space-y-2">
              <button onClick={() => exportData('json')} className="w-full text-left px-3 py-2 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-600 rounded-lg transition-all"><div className="font-medium">ðŸ“„ JSONå½¢å¼</div></button>
              <button onClick={() => exportData('text')} className="w-full text-left px-3 py-2 text-sm text-gray-700 hover:bg-green-50 hover:text-green-600 rounded-lg transition-all"><div className="font-medium">ðŸ“ ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼</div></button>
            </div>
          </div>
        </>
      )}
      {showDeleteCompletedConfirmModal && (
        <div className="fixed inset-0 z-[10000] bg-black bg-opacity-60 flex items-center justify-center p-4">
          <div className="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md relative transform transition-all scale-100 opacity-100">
            <div className="flex items-start">
              <div className="mr-4 flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100 sm:h-10 sm:w-10">
                <AlertTriangle className="h-6 w-6 text-red-600" aria-hidden="true" />
              </div>
              <div className="mt-0 text-left">
                <h3 className="text-lg leading-6 font-bold text-gray-900">
                  å®Œäº†æ¸ˆã¿ã‚¿ã‚¹ã‚¯ã®å‰Šé™¤
                </h3>
                <div className="mt-2">
                  <p className="text-sm text-gray-600">
                    æœ¬å½“ã«ã™ã¹ã¦ã®å®Œäº†æ¸ˆã¿ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å…ƒã«æˆ»ã™ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚
                  </p>
                </div>
              </div>
            </div>
            <div className="mt-6 sm:mt-8 sm:flex sm:flex-row-reverse">
              <button
                type="button"
                className="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-red-600 text-base font-medium text-white hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 sm:ml-3 sm:w-auto sm:text-sm transition-colors"
                onClick={executeDeleteCompletedTasks}
              >
                ã¯ã„ã€å‰Šé™¤ã—ã¾ã™
              </button>
              <button
                type="button"
                className="mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:mt-0 sm:w-auto sm:text-sm transition-colors"
                onClick={() => setShowDeleteCompletedConfirmModal(false)}
              >
                ã‚­ãƒ£ãƒ³ã‚»ãƒ«
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
